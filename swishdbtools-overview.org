#+TITLE:swishdbtools overview 
#+AUTHOR: Ivan Hanigan
#+email: ivan.hanigan@anu.edu.au
#+LaTeX_CLASS: article
#+LaTeX_CLASS_OPTIONS: [a4paper]
#+LATEX: \tableofcontents
-----

* Introduction
** run tests
#+name:test_project
#+begin_src R :session *R* :tangle test_project.r :exports none :eval no
  ################################################################
  # name:test_project
  require(testthat)
  test_dir('tests')
  
#+end_src

** package doc
#+name:swishdbtools-package
#+begin_src R :session *R* :tangle man/swishdbtools-package.Rd :exports none :eval no
\name{swishdbtools-package}
\alias{swishdbtools-package}
\alias{swishdbtools}
\docType{package}
\title{
getPassword and connect2postgres
}
\description{
getPassword and connect2postgres~
}
\details{
\tabular{ll}{
Package: \tab swishdbtools\cr
Type: \tab Package\cr
Version: \tab 1.0\cr
Date: \tab 2012-12-13\cr
License: \tab What license is it under?\cr
}
~~ An overview of how to use the package, including the most important functions ~~
}
\author{
Who wrote it

Maintainer: Who to complain to <ivan.hanigan@gmail.com>

}
\references{

}
\keyword{ package }
\seealso{
~~ Optional links to other man pages, e.g. ~~
~~ \code{\link[<pkg>:<pkg>-package]{<pkg>}} ~~
}
\examples{
~~ simple examples of the most important functions ~~
}

#+end_src

* functions
** add_datadscr
*** test-add_datadscr
#+name:test-add_datadscr
# tests/test-add_datadscr.r 
#+begin_src R :session *R* :tangle no :exports none :eval no
  ################################################################
  # name:test-add_datadscr
  source("R/add_datadscr.r")
  require(swishdbtools)
  if(!exists('p'))
  {
    p <- getPassword()
  }
  ewedb <- connect2postgres('localhost', db='django',
                         user='gislibrary', p=p)
  pwd <- getPassword(remote=T)
  ch <- connect2oracle('115.146.93.225', db="DDIINDEXDB", p = pwd)
  # for files that are already loaded on ewedb
  airquality <- sql_subset(ewedb, 'airquality', limit = 1, eval = T)
  airquality
  # else load the file from CSV or similar
  baseball <- read.csv('baseball.csv')
  # now add variable labels
  datadscr <- add_datadscr(data_frame = airquality, fileid = 1, ask=T)
  datadscr <- add_datadscr(data_frame = baseball, ask=T)
  
#+end_src

*** R-add_datadscr
#+name:add_datadscr
#+begin_src R :session *R* :tangle R/add_datadscr.r :exports none :eval no
  ################################################################
  # name:add_datadscr
  add_datadscr <- function(data_frame, fileid = NA,notes=NA,specperm=F,ask=F){
  
  
    labls=names(data_frame)
    datadscr=as.data.frame(matrix(nrow=length(labls),ncol=4, byrow=TRUE))
    names(datadscr)=c('LABL','NOTES','SPECPERMVAR', 'FILEID')
    datadscr$LABL=labls
    if( !is.na(notes) ){ stopifnot(length(notes) == length(labls))}
    
    if(!is.na(notes[1])) {
      datadscr$NOTES=notes
    } else if(ask==F){
      datadscr$NOTES=rep('',length(labls))
    } else {
      for(i in 1:length(labls) ){
        #if element is null then
        labl=labls[i]
        datadscr[i,1]=labl
        datadscr[i,2]=readline(paste("enter descriptions for the ",labl,": "))
        if(specperm==T) datadscr[i,3]=readline(paste("special permissions for ",labl,": "))
      }
    }
    datadscr$FILEID=fileid
    # cat(paste("write.table(f,'metadata/{study}_ddi_filedscr.csv',sep=',',row.names=F)
    #           # OR
    #           write.table(f,'metadata/{study}_ddi_filedscr.csv',sep=',',row.names=F, append=T, col.names=F)
    #           ",sep=''))
  
    return(datadscr)
    
  }
  
  
#+end_src

** add_filedscr
*** test-add_filedscr
#+name:test-add_stdydscr
# tests/test-add_filedscr.r
#+begin_src R :session *R* :tangle no :exports none :eval no
  ################################################################
  # name:test-add_stdydscr
  
  source("R/add_filedscr.r")
   
  file <- add_filedscr(fileid = 1, idno = 'R_DATASETS', ask=T)
  
  t(file)
  
  
#+end_src
*** R-add_filedscr
#+name:add_filedscr
#+begin_src R :session *R* :tangle R/add_filedscr.r :exports none :eval no
  ################################################################
  # name:add_filedscr
  add_filedscr <- function(fileid=NA,idno=NA,filename=NA,notes='NCEPH_Unrestricted',filelocation=NA,file_description='',ask=F){
    if (!require(sqldf)) install.packages('sqldf')
    require(sqldf)
    if (!require(R2HTML)) install.packages('R2HTML')
    require(R2HTML)
      
    elements = c('IDNO','FILENAME','FILETYPE','PROCSTAT','SPECPERMFILE','DATEARCHIVED','DATEDESTROY','FILEDSCR','NOTES','REQID','PUBLISHDDI','BACKUPVALID','DATEBACKUPVALID','CHECKED','BACKUPLOCATION')
    filedscr=as.data.frame(matrix(nrow=1,ncol=length(elements), byrow=TRUE))
    names(filedscr)=elements
    stopifnot(!is.na(idno)) 
    filedscr$IDNO =idno
    if(is.na(fileid)) {fileid<- readline('fileid, one number for each file in the study: ')}
    filedscr$FILEID =fileid
    if(is.na(filename)) {filename<- readline('filename: ')}
    filedscr$FILENAME =filename
    if(is.na(notes)) {notes<- readline('notes: ')}
    filedscr$NOTES =notes
  #  if(is.na(filelocation)) {filelocation <- getwd()}
    if(is.na(filelocation)) {filelocation <- readline('file_location: ')}
    filedscr$FILELOCATION =filelocation
    if(is.na(file_description)) {file_description<- readline('file_description: ')}
    filedscr$FILEDSCR=file_description
    
    if(ask==F){
      filedscr$FILELOCATION = getwd()
      filedscr$FILETYPE =''
      filedscr$PROCSTAT =''
      filedscr$SPECPERMFILE =''
      filedscr$DATEARCHIVED =''
      filedscr$DATEDESTROY =''
      filedscr$REQID =''
      filedscr$PUBLISHDDI =''
      filedscr$BACKUPVALID =''
      filedscr$DATEBACKUPVALID =''
      filedscr$CHECKED =''
      filedscr$BACKUPLOCATION =''
    } else {
      for(i in 3:length(elements)){
        element=elements[i]
        filedscr[1,i]=readline(paste("enter descriptions for the ",element,": "))
      }
    }
    
    return(filedscr)
  }
  
#+end_src

** add_stdydscr
*** test-add_stdydscr
#+name:test-add_stdydscr
# tests/test-add_stdydscr.r
#+begin_src R :session *R* :tangle no :exports none :eval no
  ################################################################
  # name:test-add_stdydscr
  source("R/connect2oracle.r")
  source("R/add_stdydscr.r")
  source("R/getPassword.r")
  
  pwd <- getPassword(remote=T)
  ch <- connect2oracle('115.146.93.225', db="DDIINDEXDB", p = pwd)
  
  stdy <- add_stdydscr(idno='R_DATASETS', 'The R Datasets Package
  Description',
                       ask = T)
  t(stdy)
  
  
#+end_src

*** R-add_stdydscr
#+name:add_stdydscr
#+begin_src R :session *R* :tangle R/add_stdydscr.r :exports none :eval no
  t################################################################
  # name:add_stdydscr
  
  add_stdydscr <- function(idno=NA,titl=NA,abstract=NA,authoring_entity_of_data=NA,
  distrbtr='NCEPH data manager',bibliographic_citation=NA,notes='NCEPH Unrestricted', restrctn=NA,datakind='OTHER',ask=F){
  if (!require(sqldf)) install.packages('sqldf')
  require(sqldf)
  if (!require(R2HTML)) install.packages('R2HTML')
  require(R2HTML)
    
    elements = c('TITL','IDNO','PRODUCER','PRODDATEDOC','BIBLCITDOC','AUTHENTY','COPYRIGHT','PRODDATESTDY','FUNDAG','DISTRBTR','SERNAME','VERSION','BIBLCITSTDY','TIMEPRD','COLLDATE','GEOGCOVER','GEOGUNIT','ANLYUNIT','UNIVERSE','DATAKIND','CLEANOPS','CONFDEC','SPECPERM','RESTRCTN','NOTES','ABSTRACT')
    
    stdydscr=as.data.frame(matrix(nrow=1,ncol=length(elements), byrow=TRUE))
    names(stdydscr)=elements
    if(is.na(titl)) {titl<- readline('title of study: ')}
    stdydscr$TITL =titl
    if(is.na(idno)) {idno<- readline('ID code of study: ')}
    stdydscr$IDNO =idno
    if(is.na(abstract)) {abstract<- readline('abstract: ')}
    stdydscr$ABSTRACT =abstract
    if(is.na(authoring_entity_of_data)) {authoring_entity_of_data<- readline('authoring_entity_of_data: ')}
    stdydscr$AUTHENTY =authoring_entity_of_data
    # auto
    stdydscr$PRODDATEDOC =Sys.Date()
    
    if(ask==F){
      stdydscr$PRODUCER =''
      
      stdydscr$BIBLCITDOC =''
      stdydscr$COPYRIGHT =''
      stdydscr$PRODDATESTDY =''
      stdydscr$FUNDAG =''
      stdydscr$DISTRBTR = distrbtr
      stdydscr$SERNAME =''
      stdydscr$VERSION =''
      stdydscr$BIBLCITSTDY =bibliographic_citation
      stdydscr$TIMEPRD =''
      stdydscr$COLLDATE =''
      stdydscr$GEOGCOVER =''
      stdydscr$GEOGUNIT =''
      stdydscr$ANLYUNIT =''
      stdydscr$UNIVERSE =''
      stdydscr$DATAKIND =datakind
      stdydscr$CLEANOPS =''
      stdydscr$CONFDEC =''
      stdydscr$SPECPERM =''
      stdydscr$RESTRCTN =restrctn
      stdydscr$NOTES =notes
      
    } else {
      for(i in c(7:(length(elements)-1))){
        element=elements[i]
        stdydscr[1,i]=readline(paste("enter descriptions for the ",element,": "))
      }
    }
    stdydscr$PRODDATESTDY <- format(as.Date( substr(stdydscr$PRODDATESTDY,1,10),'%Y-%m-%d'),"%d/%b/%Y")
    stdydscr$PRODDATEDOC <- format(as.Date( substr(stdydscr$PRODDATEDOC,1,10),'%Y-%m-%d'),"%d/%b/%Y")



    # TASK add a caveat that if NOTES is null then NCEPH Unrestricted
    return(stdydscr)
  }
  
  
#+end_src
** connect2oracle
*** test-connect2oracle
#+name:connect2oracle
# tests/test-connect2oracle.r
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:connect2oracle

#+end_src
*** R-connect2oracle
#+name:connect2oracle
#+begin_src R :session *R* :tangle R/connect2oracle.r :exports none :eval no
################################################################
# name:connect2oracle
# make sure you have JDK, if not install the SUN version
#http://blog.i-evaluation.com/2012/12/03/installing-java-sdk-and-jre-bin-files-on-my-ec2-instance/
# then get the JDBC driver from http://www.oracle.com/technetwork/database/enterprise-edition/jdbc-112010-090769.html
# put into /lib
##  did install.packages('rJava') and then
# "R CMD javareconf" as root
connect2oracle <- function(hostip=NA, db=NA, p=NA,
                           driverlocation='/lib/ojdbc6.jar'){
  if(!require(RJDBC)) install.packages('RJDBC'); require(RJDBC)
  drv <- JDBC("oracle.jdbc.driver.OracleDriver",
              '/lib/ojdbc6.jar')
  
  if(is.na(hostip)){
    hostip=readline('enter hostip: ')
  }
  if(is.na(db)){
    db=readline('enter db: ')
  }

  if(is.na(p)){
    pwd=readline(paste('enter password for ',db, ': ',sep=''))
  } else {
    pwd <- p
  }
  
  ch <- dbConnect(drv,paste("jdbc:oracle:thin:@",hostip,":1521",sep=''),db,pwd)
  return(ch)
}

#+end_src
*** man-connect2oracle
#+name:connect2oracle
#+begin_src R :session *R* :tangle man/connect2oracle.Rd :exports none :eval no
\name{connect2oracle}
\alias{connect2oracle}
%- Also NEED an '\alias' for EACH other topic documented here.
\title{
connect to a oracle db
}
\description{
connect to a oracle db
}
\usage{
connect2oracle(hostip=NA, db=NA, p=NA, driverlocation='/lib/ojdbc6.jar')
}
%- maybe also 'usage' for other objects documented here.
\arguments{

  \item{hostip}{
IP address as string
}
  \item{db}{
Database (Workspace) name 
}
  \item{p}{
password 
}
  \item{driverlocation}{
defaults to linux location.  not tested on windoze.
}

}

\details{
%%  ~~ If necessary, more details than the description above ~~
}
\value{
%%  ~Describe the value returned
%%  If it is a LIST, use
%%  \item{comp1 }{Description of 'comp1'}
%%  \item{comp2 }{Description of 'comp2'}
%% ...
}
\references{
%% ~put references to the literature/web site here ~
}
\author{
ivanhanigan
}
\note{
make sure you have JDK, if not install the SUN version
http://blog.i-evaluation.com/2012/12/03/installing-java-sdk-and-jre-bin-files-on-my-ec2-instance/
then get the JDBC driver from http://www.oracle.com/technetwork/database/enterprise-edition/jdbc-112010-090769.html
put into /lib
did install.packages('rJava') and then
"R CMD javareconf" as root
}

%% ~Make other sections like Warning with \section{Warning }{....} ~

\seealso{
%% ~~objects to See Also as \code{\link{help}}, ~~~
}
\examples{
# example using the SWISH Extreme Weather Eventds DataBase (EWEDB).
# NB only powerusers will know the password.
ch <- connect2oracle(hostip = '115.146.93.225', db = 'DDIINDEXDB')
stdydscr <- dbGetQuery(ch, "select * from stdydscr where IDNO = 'EWEDB'")
t(stdydscr)



}
% Add one or more standard keywords, see file 'KEYWORDS' in the
% R documentation directory.
\keyword{ ~kwd1 }
\keyword{ ~kwd2 }% __ONLY ONE__ keyword per line

#+end_src

** connect2postgres
*** test-connect2postgres
#+name:connect2postgres
# tests/test-connect2postgres.r
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:connect2postgres

#+end_src
*** R-connect2postgres
#+name:connect2postgres
#+begin_src R :session *R* :tangle R/connect2postgres.r :exports none :eval no
#################
# connect2postgres

connect2postgres <- function(hostip=NA,db=NA,user=NA, p=NA, os = 'linux', pgutils = c('c:/pgutils')){
 if(is.na(hostip)){
 hostip=readline('enter hostip: ')
 } 
 if(is.na(db)){
 db=readline('enter db: ')
 }
 if(is.na(user)){
 user=readline('enter user: ')
 }
 if(is.na(p)){
 pwd=readline(paste('enter password for user ',user, ': ',sep=''))
 } else {
 pwd <- p
 }
 #if(os == 'linux'){
  if (!require(RPostgreSQL)) install.packages('RPostgreSQL', repos='http://cran.csiro.au'); require(RPostgreSQL)
  con <- dbConnect(PostgreSQL(),host=hostip, user= user, password=pwd, dbname=db)
#  } else { 
#   if (!require(RJDBC)) install.packages('RJDBC'); require(RJDBC) 
#   # This downloads the JDBC driver to your selected directory if needed
#   if (!file.exists(file.path(pgutils,'postgresql-8.4-701.jdbc4.jar'))) {
#   dir.create(pgutils,recursive =T)
#   download.file('http://jdbc.postgresql.org/download/postgresql-8.4-701.jdbc4.jar',file.path(pgutils,'postgresql-8.4-701.jdbc4.jar'),mode='wb')
#   }
#   # connect
#   pgsql <- JDBC( 'org.postgresql.Driver', file.path(pgutils,'postgresql-8.4-701.jdbc4.jar'))
#   con <- dbConnect(pgsql, paste('jdbc:postgresql://',hostip,'/',db,sep=''), user = user, password = pwd)
#  }
 # clean up
 rm(pwd)
 return(con)
 }
 #  ch <- connect2postgres()
 # enter password at console

#+end_src
*** man-connect2postgres
#+name:connect2postgres
#+begin_src R :session *R* :tangle man/connect2postgres.Rd :exports none :eval no
\name{connect2postgres}
\alias{connect2postgres}
%- Also NEED an '\alias' for EACH other topic documented here.
\title{
connect to a postgres db
}
\description{
connect to a postgres db
}
\usage{
connect2postgres(hostip = NA, db = NA, user = NA, p = NA, os = "linux", pgutils = c("/home/ivan/tools/jdbc", "c:/pgutils"))
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{hostip}{
%%     ~~Describe \code{hostip} here~~
}
  \item{db}{
%%     ~~Describe \code{db} here~~
}
  \item{user}{
%%     ~~Describe \code{user} here~~
}
  \item{p}{
%%     ~~Describe \code{p} here~~
}
  \item{os}{
%%     ~~Describe \code{os} here~~
}
  \item{pgutils}{
%%     ~~Describe \code{pgutils} here~~
}
}
\details{
%%  ~~ If necessary, more details than the description above ~~
}
\value{
%%  ~Describe the value returned
%%  If it is a LIST, use
%%  \item{comp1 }{Description of 'comp1'}
%%  \item{comp2 }{Description of 'comp2'}
%% ...
}
\references{
%% ~put references to the literature/web site here ~
}
\author{
ivanhanigan
}
\note{
%%  ~~further notes~~
}

%% ~Make other sections like Warning with \section{Warning }{....} ~

\seealso{
%% ~~objects to See Also as \code{\link{help}}, ~~~
}
\examples{
##---- Should be DIRECTLY executable !! ----
##-- ==>  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (hostip = NA, db = NA, user = NA, p = NA, os = "linux", 
    pgutils = c("/home/ivan/tools/jdbc", "c:/pgutils")) 
{
    if (is.na(hostip)) {
        hostip = readline("enter hostip: ")
    }
    if (is.na(db)) {
        db = readline("enter db: ")
    }
    if (is.na(user)) {
        user = readline("enter user: ")
    }
    if (is.na(p)) {
        pwd = readline(paste("enter password for user ", user, 
            ": ", sep = ""))
    }
    else {
        pwd <- p
    }
    if (os == "linux") {
        if (!require(RPostgreSQL)) 
            install.packages("RPostgreSQL", repos = "http://cran.csiro.au")
        require(RPostgreSQL)
        con <- dbConnect(PostgreSQL(), host = hostip, user = user, 
            password = pwd, dbname = db)
    }
    else {
        if (!require(RJDBC)) 
            install.packages("RJDBC")
        require(RJDBC)
        if (!file.exists(file.path(pgutils, "postgresql-8.4-701.jdbc4.jar"))) {
            dir.create(pgutils, recursive = T)
            download.file("http://jdbc.postgresql.org/download/postgresql-8.4-701.jdbc4.jar", 
                file.path(pgutils, "postgresql-8.4-701.jdbc4.jar"), 
                mode = "wb")
        }
        pgsql <- JDBC("org.postgresql.Driver", file.path(pgutils, 
            "postgresql-8.4-701.jdbc4.jar"))
        con <- dbConnect(pgsql, paste("jdbc:postgresql://", hostip, 
            "/", db, sep = ""), user = user, password = pwd)
    }
    rm(pwd)
    return(con)
  }
}
% Add one or more standard keywords, see file 'KEYWORDS' in the
% R documentation directory.
\keyword{ ~kwd1 }
\keyword{ ~kwd2 }% __ONLY ONE__ keyword per line

#+end_src

** connect2postgres2
*** test-connect2postgres2
#+name:connect2postgres2
# tests/test-connect2postgres2.r
#+begin_src R :session *R* :tangle no :exports none :eval no
  ################################################################
  # name:connect2postgres2
    source("R/LinuxOperatingSystem.r")
    source("R/get_pgpass.r")
    source("R/connect2postgres.r")
    source("R/connect2postgres2.r")
  
  #  debug(connect2postgres2)
    ch <- connect2postgres2("ewedb", "115.146.84.135", "ivan_hanigan")
    dbGetQuery(ch, 'select * from dbsize')
  debug(connect2postgres2)
    ch <- connect2postgres2("ewedb")
    dbGetQuery(ch, 'select * from dbsize')
#+end_src
*** R-connect2postgres2
#+name:connect2postgres2
#+begin_src R :session *R* :tangle R/connect2postgres2.r :exports none :eval no
  ################################################################
  # name:connect2postgres2
  connect2postgres2 <- function(database, host=NA, user = NA)
  {
  if(!require(fgui)) install.packages("fgui", repos='http://cran.csiro.au'); require(fgui)
    if(is.na(host) | is.na(user))
    {
      # try to find unique record for that database
      passwordTable <- get_passwordTable()
      recordIndex <- which(passwordTable$V3 == database)
      if(length(recordIndex) == 1)
        {
          pgpass <- passwordTable[recordIndex,]
        } else {
  
        # if not found then ask the user for ip and uname
        pgpass <- guiv(get_pgpass,
                      argOption=list(savePassword=c("TRUE","FALSE")))
      }
        ch <- connect2postgres(hostip = pgpass[1], db=database,
                              user=pgpass[4], p = pgpass[5])
  
    } else {
     pgpass <- get_pgpass(database = database, host = host, user = user)
     ch <- connect2postgres(hostip = host, db=database,
                            user=user, p = pgpass[5])
    }
  
     return(ch)
  }
  
#+end_src
*** man-connect2postgres2
#+name:connect2postgres2
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:connect2postgres2

#+end_src

** ddiindexdb_remove_file
*** test-ddiindexdb_remove_file
#+name:ddiindexdb_remove_file
# tests/test-ddiindexdb_remove_file.r
#+begin_src R :session *R* :tangle no :exports none :eval no
  ################################################################
  # name:ddiindexdb_remove_file
  require(swishdbtools)
  source("R/ddiindexdb_remove_file.r")
  p <- getPassword()
  ddiindexdb <- connect2oracle('115.146.93.225', 'ddiindexdb', p = p)
  ddiindexdb_remove_file(ddiindexdb, x = "public.baseball")
  
#+end_src
*** R-ddiindexdb_remove_file
#+name:ddiindexdb_remove_file
#+begin_src R :session *R* :tangle R/ddiindexdb_remove_file.r :exports none :eval no
    ################################################################
    # name:ddiindexdb_remove_file
  
    ddiindexdb_remove_file <- function(conn, x)
    {
    if(length(grep("\\.",x)) == 0)
      {
        schema <- "public"
        table <- x
      } else {
        schema <- strsplit(x, "\\.")[[1]][1]
        table <- strsplit(x, "\\.")[[1]][2]
      }
  
    fid <- dbGetQuery(ch,
                paste("delete from ddiindexdb.filedscr where filelocation = '",schema,"'  and filename = '",table,"'", sep ="")
                     )
  #  fid
  
    dbSendUpdate(ch,
                paste("delete from ddiindexdb.datadscr where fileid = ",
                fid[1,1], sep ="")
                )
  
    dbSendUpdate(ch,
                paste("delete from ddiindexdb.filedscr where filelocation = '",schema,"'  and filename = '",table,"'", sep ="")
                )
    }
  
#+end_src
*** man-ddiindexdb_remove_file
#+name:ddiindexdb_remove_file
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:ddiindexdb_remove_file

#+end_src

** DEPRECATED df2ddi
** ddiindexdb_sync_study
*** test-ddiindexdb_sync_study
#+name:ddiindexdb_sync_study
# tests/test-ddiindexdb_sync_study.r
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:ddiindexdb_sync_study

#+end_src
*** R-ddiindexdb_sync_study
#+name:ddiindexdb_sync_study
#+begin_src R :session *R* :tangle R/ddiindexdb_sync_study.r :exports none :eval no
################################################################
# name:ddiindexdb_sync_study

#+end_src
*** man-ddiindexdb_sync_study
#+name:ddiindexdb_sync_study
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:ddiindexdb_sync_study

#+end_src

** sql_tsfill
*** test-sql_tsfill
#+name:sql_tsfill
#+begin_src R :session *R* :tangle tests/test-sql_tsfill.r :exports none :eval no
  ################################################################
  # name:sql_tsfill
  # # Example use FillCategoryTimeSeries
  # FillTest.csv is a file containing incomplete values for table with columns factorA, factorB, and value
  source("../R/sql_tsfill.r")
  require(sqldf)
  #sparseTable <- read.csv("../FillTest.csv")
  sparseTable <- "factorA, factorB, value
  A, X, 1
  A, Z, 2
  B, Y, 3
  "
  tableIn <- read.csv(textConnection(sparseTable))
  variable1 <- as.data.frame(toupper(letters[1:4]))
  names(variable1) <- 'factorA'
  
  variable2 <- as.data.frame(c(1:3))
  names(variable2) <- 'factorB'
  
  filledTable <- sql_tsfill(tableIn, "value", -1, variable1, variable2)
  #filledTable
  
  correct <- "factorA, factorB, value
  A,       1,    -1
  A,       2,    -1
  A,       3,    -1
  B,       1,    -1
  B,       2,    -1
  B,       3,    -1
  C,       1,    -1
  C,       2,    -1
  C,       3,    -1
  D,       1,    -1
  D,       2,    -1
  D,       3,    -1
  "
  correct <- read.csv(textConnection(correct), stringsAsFactors = FALSE)
  #str(correct)
  #str(filledTable)
  test_that('tsfill returns correct',
            {
              expect_that(identical(filledTable, correct), is_true())
            }
  )
  
#+end_src
*** R-sql_tsfill
#+name:sql_tsfill
#+begin_src R :session *R* :tangle R/sql_tsfill.r :exports none :eval no
################################################################
# name:sql_tsfill
# NB see http://www.ats.ucla.edu/stat/stata/faq/fill_down.htm
# fills a variable in a table for missing combinations of variable1 ... variableN
# returns filled table
# 'variableName' to be filled
# 'fillValue' for filled variable 
# 'variable1' values for category variable 1, where names(variable1) is the name of variable1
# variable2, ...,  variableN - values and names of category variable 2 ... N
sql_tsfill <- function(tableIn, variableName, fillValue, variable1, ...)
{
  argumentNames <- c(deparse(substitute(variable1)), sapply(substitute(list(...))[-1], deparse))
  argumentNames <- paste(collapse = ", ", argumentNames)
  
  categoryExpression <- paste(sep = "", "t1.", names(variable1) ," = t2.", names(variable1))
  otherVariables <- list(...)
  for(variableIndex in 1:length(otherVariables)) 
  {
    variable <- otherVariables[[variableIndex]]
    categoryExpression <- paste(sep="", categoryExpression, "\r\n", " and ", "t1.", names(variable), " = t2.", names(variable))
  }
  
  tableName <- deparse(substitute(tableIn))
  case <- paste(sep = "", "case when ", variableName, " is null then ", fillValue, " else ", variableName, " end")
  joinExpression <- paste(sep = "", "(select * from ", argumentNames,") ", "\r\n", "t1 left join ", tableName, " t2 on ", "\r\n", categoryExpression)
  sql <- paste(sep = "", "select t1.*, ", "\r\n", case, "\r\n", " as ", variableName, " from ", "\r\n", joinExpression)
  
  tableOut <-  sqldf(sql, drv = 'SQLite')
  
  return(tableOut)
}



#+end_src
*** man-sql_tsfill
#+name:sql_tsfill
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:sql_tsfill

#+end_src

*** COMMENT versions
**** Ian's orig src-FillCategoryTimeSeries
#+name:FillCategoryTimeSeries
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:FillCategoryTimeSeries

# fills a variable in a table for missing combinations of variable1 ... variableN
# returns filled table
# 'variableName' to be filled
# 'fillValue' for filled variable 
# 'variable1' values for category variable 1, where names(variable1) is the name of variable1
# variable2, ...,  variableN - values and names of category variable 2 ... N
FillCategoryTimeSeries<-function(tableIn, variableName, fillValue, variable1, ...)
{
  argumentNames <- c(deparse(substitute(variable1)), sapply(substitute(list(...))[-1], deparse))
  argumentNames <- paste(collapse = ", ", argumentNames)
  
  categoryExpression <- paste(sep = "", "t1.", names(variable1) ," = t2.", names(variable1))
  otherVariables <- list(...)
  for(variableIndex in 1:length(otherVariables)) 
  {
    variable <- otherVariables[[variableIndex]]
    categoryExpression <- paste(sep="", categoryExpression, "\r\n", " and ", "t1.", names(variable), " = t2.", names(variable))
  }
  
  tableName <- deparse(substitute(tableIn))
  case <- paste(sep = "", "case when ", variableName, " is null then ", fillValue, " else ", variableName, " end")
  joinExpression <- paste(sep = "", "(select * from ", argumentNames,") ", "\r\n", "t1 left join ", tableName, " t2 on ", "\r\n", categoryExpression)
  sql <- paste(sep = "", "select t1.*, ", "\r\n", case, "\r\n", " as ", variableName, " from ", "\r\n", joinExpression)
  
  tableOut <-  sqldf(sql, drv = 'SQLite')
  
  return(tableOut)
}

# # Example use FillCategoryTimeSeries
# # FillTest.csv is a file containing incomplete values for table with columns factorA, factorB, and value
# 
# sparseTable <- read.csv("FillTest.csv") 
# 
# variable1 = as.data.frame(toupper(letters[1:4]))
# names(variable1) <- 'factorA'
# 
# variable2 =  as.data.frame(c(1:3))
# names(variable2) <- 'factorB'
# 
# filledTable = FillCategoryTimeSeries(tableIn, "value", -1, variable1, variable2)
# 


#+end_src

** getPassword
*** test-getPassword
#+name:getPassword
#+begin_src R :session *R* :tangle tests/test-getPassword.r :exports none :eval no
source("../R/getPassword.r")
test_that('password returns string with characters', {
  expect_that(nchar(getPassword(remote = T))>0, is_true())
#  expect_that(nchar(getPassword(remote = F))>0, is_true())
  # getPassword(remote = T))
  # expect_that(is.character(getPassword(remote = T)), is_true)
})


# dev tests
# getPassword(remote = T)
# getPassword(remote = F)
#+end_src
*** R-getPassword
#+name:getPassword
#+begin_src R :session *R* :tangle R/getPassword.r :exports none :eval no

###########################################################################
# newnode: getPassword
getPassword <- function(remote = F){
  if(remote == F){
   require(tcltk)
   tt <- tktoplevel()
   pass=tclVar('')
   label.widget <- tklabel(tt, text='Enter Password')
   password.widget <- tkentry(tt,show='*',textvariable=pass)
   ok <- tkbutton(tt,text='Ok',command=function()tkdestroy(tt))
   tkpack(label.widget, password.widget,ok)
   tkwait.window(tt)
   return(tclvalue(pass))
 } else {
   pass <- readline('Type your password into the console: ')
   return(pass)
 }
}


# pwd <- getPassword()

#+end_src
*** man-getPassword
#+name:getPassword
#+begin_src R :session *R* :tangle man/getPassword.Rd :exports none :eval no
\name{getPassword}
\alias{getPassword}
%- Also NEED an '\alias' for EACH other topic documented here.
\title{
getPassword
}
\description{
getPassword
}
\usage{
getPassword(remote = F)
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{remote}{
%%     ~~Describe \code{remote} here~~
}
}
\details{
%%  ~~ If necessary, more details than the description above ~~
}
\value{
%%  ~Describe the value returned
%%  If it is a LIST, use
%%  \item{comp1 }{Description of 'comp1'}
%%  \item{comp2 }{Description of 'comp2'}
%% ...
}
\references{
%% ~put references to the literature/web site here ~
}
\author{
ivanhanigan
}
\note{
%%  ~~further notes~~
}

%% ~Make other sections like Warning with \section{Warning }{....} ~

\seealso{
%% ~~objects to See Also as \code{\link{help}}, ~~~
}
\examples{
##---- Should be DIRECTLY executable !! ----
##-- ==>  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (remote = F) 
{
    if (remote == F) {
        require(tcltk)
        tt <- tktoplevel()
        pass = tclVar("")
        label.widget <- tklabel(tt, text = "Enter Password")
        password.widget <- tkentry(tt, show = "*", textvariable = pass)
        ok <- tkbutton(tt, text = "Ok", command = function() tkdestroy(tt))
        tkpack(label.widget, password.widget, ok)
        tkwait.window(tt)
        return(tclvalue(pass))
    }
    else {
        pass <- readline("Type your password into the console: ")
        return(pass)
    }
  }
}
% Add one or more standard keywords, see file 'KEYWORDS' in the
% R documentation directory.
\keyword{ ~kwd1 }
\keyword{ ~kwd2 }% __ONLY ONE__ keyword per line
#+end_src

** get_passwordTable
*** test-get_passwordTable
#+name:get_passwordTable
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:get_passwordTable

#+end_src
*** R-get_passwordTable
#+name:get_passwordTable
#+begin_src R :session *R* :tangle R/get_passwordTable.r :exports none :eval no
################################################################
# name:get_passwordTable
    get_passwordTable <- function(fileName)
    {
      linux <- LinuxOperatingSystem()
      if(linux)
      {
        fileName <- "~/.pgpass"
      } else
      {
        directory <- Sys.getenv("APPDATA")
        fileName <- file.path(directory, "postgresql", "pgpass.conf")
      }
  
      exists <- file.exists(fileName)
      if (exists)
      {
        passwordTable <- read.table(fileName, sep = ":", stringsAsFactors=FALSE)
        return(passwordTable)
      }
  
    }
#+end_src
*** man-get_passwordTable
#+name:get_passwordTable
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:get_passwordTable

#+end_src

** get_pgpass
*** test-get_pgpass
#+name:get_pgpass
# tests/test-get_pgpass.r 
#+begin_src R :session *R* :tangle no :exports none :eval no
  ################################################################
  # name:get_pgpass
  source("R/LinuxOperatingSystem.r")
  source("R/get_pgpass.r")
  
  #undebug(get_pgpass)
  pgpass <- get_pgpass(database = "ewedb", host="115.146.84.135", user="ivan_hanigan", savePassword = TRUE)
  pgpass
  
#+end_src
*** R-get_pgpass
#+name:get_pgpass
#+begin_src R :session *R* :tangle R/get_pgpass.r :exports none :eval no
  ################################################################
  # name:get_pgpass



  get_pgpass <- function(database, host, user, savePassword = FALSE)
  {

    linux <- LinuxOperatingSystem()
    if(linux)
    {
      fileName <- "~/.pgpass"
    } else
    {
      directory <- Sys.getenv("APPDATA")
      fileName <- file.path(directory, "postgresql", "pgpass.conf")
    }
#    passwordTable <- get_passwordTable(fileName = fileName)
    exists <- file.exists(fileName)
    if (!exists & !linux)
    {
      dir.create(file.path(directory, "postgresql"))
    } else {
      passwordTable <- read.table(fileName, sep = ":", stringsAsFactors=FALSE)
      #return(passwordTable)
    }
    if(exists('passwordTable'))
    {
      hostColumn <- 1
      databaseColumn <- 3
      userColumn <- 4
      passwordColumn <- 5

      recordIndex <- which(passwordTable[,hostColumn] == host &
      passwordTable[,databaseColumn] == database & passwordTable[,userColumn] == user)

      if (length(recordIndex > 0) > 0)
      {
        pwd <- passwordTable[recordIndex, passwordColumn]
        pwd <- as.character(pwd)

      
      } else {

        pwd <- swishdbtools::getPassword()
      }
    } else {
      pwd <- swishdbtools::getPassword()
      recordIndex <- NULL
    }
      record <- c(V1 = host, V2 = "5432", V3 = database, V4 = user, V5 = pwd)
      #record <- paste(host, ":5432:*:",  user,":",  pgpass, collapse = "", sep = "")
      record <- t(record)
    #TODO get user ok here, also on linux need to add
"WARNING: You have opted to save your password. It will be stored in plain text in your project files and in your home directory on Unix-like systems, or in your user profile on Windows. If you do not want this to happen, please press the Cancel button."

    #savePassword = TRUE

    if (savePassword & length(recordIndex > 0) == 0)
    {

      if (!exists("passwordTable"))
      {
        passwordTable <- as.data.frame(record)
      }else
      {
        passwordTable = rbind(passwordTable, record)
      }

      write.table(x = passwordTable, file = fileName, sep = ":", eol =
    "\r\n", row.names = FALSE, col.names = FALSE, quote = FALSE)
    }

    return (record)
  }

#+end_src


*** man-get_pgpass
#+name:get_pgpass
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:get_pgpass

#+end_src

** LinuxOperatingSystem
*** test-LinuxOperatingSystem
#+name:LinuxOperatingSystem
# tests/test-LinuxOperatingSystem.r
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:LinuxOperatingSystem

#+end_src
*** R-LinuxOperatingSystem
#+name:LinuxOperatingSystem
#+begin_src R :session *R* :tangle R/LinuxOperatingSystem.r :exports none :eval no
################################################################
# name:LinuxOperatingSystem
LinuxOperatingSystem <- function()
{
  if(length(grep('linux',sessionInfo()[[1]]$os)) == 1)
  {
    #print('Linux')
    os <- 'linux' 
    OsLinux <- TRUE
  }else if (length(grep('ming',sessionInfo()[[1]]$os)) == 1)
  {
    #print('Windows')
    os <- 'windows'
    OsLinux <- FALSE
  }else
  {
    # don't know, do more tests
    print('Non linux or windows os detected. Assume linux-alike.')
    os <- 'linux?'
  }
 
  return (OsLinux)
}
#+end_src
*** man-LinuxOperatingSystem
#+name:LinuxOperatingSystem
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:LinuxOperatingSystem

#+end_src

** load2ddiindex_data
*** test-load2ddiindex_data
#+name:load2ddiindex_data
# tests/test-load2ddiindex_data.r
#+begin_src R :session *R* :tangle no :exports none :eval no
  ################################################################
  # name:load2ddiindex_data
  source('R/load2ddiindex_data.r')
  require(swishdbtools)
  
  p <- getPassword()
  ch <- connect2oracle('115.146.93.225', db='DDIINDEXDB', p=p)
  load2ddiindex_data(ch, filepath = "public.baseball", datadscr)
#+end_src
*** R-load2ddiindex_data
#+name:load2ddiindex_data
#+begin_src R :session *R* :tangle R/load2ddiindex_data.r :exports none :eval no
  ################################################################
  # name:load2ddiindex_data
  
  load2ddiindex_data <- function(conn, filepath, datadscr)
   {
     if(length(grep("\\.",filepath)) == 0)
      {
        schema <- "public"
        table <- filepath
      } else {
        schema <- strsplit(filepath, "\\.")[[1]][1]
        table <- strsplit(filepath, "\\.")[[1]][2]
      }

  sql <- sql_subset(ch, 'ddiindexdb.filedscr',
                    subset = paste("filelocation = '",schema,"' and filename = '",table,"'", sep =""),
                    eval=F, check =F)
  #cat(sql)
  file <- dbGetQuery(ch, sql)
  fid <- file$FILEID
  #fid
  datadscr$FILEID <- fid
  for(i in 1:nrow(datadscr))
    {
    dbSendUpdate(ch,
      paste('
      insert into DATADSCR (',paste(names(datadscr), sep = '', collapse = ', '),')
      VALUES (',paste("'",paste(gsub("'","",ifelse(is.na(datadscr[i,]),'',datadscr[i,])),sep='',collapse="', '"),"'",sep=''),')',sep='')
     )
  
    }
  }
  
#+end_src
*** man-load2ddiindex_data
#+name:load2ddiindex_data
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:load2ddiindex_data

#+end_src

** load2ddiindex_file
*** test-load2ddiindex_file
#+name:load2ddiindex_file
# tests/test-load2ddiindex_file.r
#+begin_src R :session *R* :tangle no :exports none :eval no
  ################################################################
  # name:load2ddiindex_file
    source("R/connect2oracle.r")
    source("R/add_filedscr.r")
    source("R/getPassword.r")
    source("R/load2ddiindex_file.r")
    
    pwd <- getPassword(remote=T)
    ch <- connect2oracle('115.146.93.225', db="DDIINDEXDB", p = pwd)
    if(!exists('file'))
    {
      file <- add_filedscr(ask = T)
    }
  
    load2ddiindex_file(conn = ch, file)
    
  
#+end_src
*** R-load2ddiindex_file
#+name:load2ddiindex_file
#+begin_src R :session *R* :tangle R/load2ddiindex_file.r :exports none :eval no
  ################################################################
  # name:load2ddiindex_file
    
    load2ddiindex_file <- function(conn=NA, filedscr)
    {
    
    
    
      if(exists('filedscr'))
        {
        fileexists <- dbGetQuery(conn,
                    paste("select * from filedscr where filename = '",filedscr$FILENAME,"' and filelocation ='",filedscr$FILELOCATION,"'", sep="")
                    )
        if(nrow(fileexists) > 0) stop('File record already exists.')
  
        filedscr$PRODDATEDOCFILE <- format(as.Date( substr(filedscr$PRODDATEDOCFILE,1,10),'%Y-%m-%d'),"%d/%b/%Y")
        
      dbSendUpdate(ch,
      # cat(
        paste('
        insert into FILEDSCR (',paste(names(filedscr), sep = '', collapse = ', '),')
        VALUES (',paste("'",paste(gsub("'","",ifelse(is.na(filedscr),'',filedscr)),sep='',collapse="', '"),"'",sep=''),')',sep='')
      )
    
        }
    }
  
#+end_src
*** man-load2ddiindex_file
#+name:load2ddiindex_file
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:load2ddiindex_file

#+end_src

** load2ddiindex_study
*** test-load2ddiindex_study
#+name:test-load2ddiindex_study
# tests/test-load2ddiindex_study.r
#+begin_src R :session *R* :tangle no :exports none :eval no
  ################################################################
  # name:test-load2ddiindex_study
  source("R/connect2oracle.r")
  source("R/add_stdydscr.r")
  source("R/getPassword.r")
  source("R/load2ddiindex_study.r")
  
  pwd <- getPassword(remote=T)
  ch <- connect2oracle('115.146.93.225', db="DDIINDEXDB", p = pwd)
  if(!exists('stdy'))
  {
    stdy <- add_stdydscr(ask = T)
  }
  t(stdy)
  
  load2ddiindex_study(conn = ch, stdy)
  
#+end_src

*** R-load2ddiindex_study
#+name:load2ddiindex_study
#+begin_src R :session *R* :tangle R/load2ddiindex_study.r :exports none :eval no
  ################################################################
  # name:load2ddiindex_study
  load2ddiindex_study <- function(conn=NA, stdydscr)
  {
  
    if(exists('stdydscr'))
      {
        stdyexists <- dbGetQuery(conn,
                  paste("select * from stdydscr where idno = '",stdydscr$IDNO,"'", sep="")
                  )
      if(nrow(stdyexists) > 0) stop('Study record already exists.')
  # format dates for oracle
    stdydscr$PRODDATESTDY <- format(as.Date( substr(stdydscr$PRODDATESTDY,1,10),'%Y-%m-%d'),"%d/%b/%Y")
    stdydscr$PRODDATEDOC <- format(as.Date( substr(stdydscr$PRODDATEDOC,1,10),'%Y-%m-%d'),"%d/%b/%Y")
  
    dbSendUpdate(conn,
    #   cat(
      paste('
      insert into STDYDSCR (',paste(names(stdydscr), sep = '', collapse = ', '),')
      VALUES (',paste("'",paste(gsub("'","",ifelse(is.na(stdydscr),'',stdydscr)),sep='',collapse="', '"),"'",sep=''),')',sep='')
      )
    }
  }
  
#+end_src
** load2postgres
*** test-load2postgres
#+name:test-load2postgres
# tests/test-load2postgres.r
#+begin_src R :session *R* :tangle no :exports none :eval no
  ################################################################
  # name:test-load2postgres
  source("R/load2postgres.r")
  #### from subset man page ####
  head(subset(airquality, Temp > 80, select = c(Ozone, Temp)))
  str(airquality)
  tempdata <- airquality
  names(tempdata) <- tolower(names(tempdata))
  names(tempdata) <- gsub('\\.', '_',names(tempdata))
  str(tempdata)
  # dbWriteTable(ch, 'airquality', tempdata)
  write.csv(tempdata, 'airquality.csv', row.names=F, na = "")
  # rm(tempdata)
  require(swishdbtools)
  if(!exists('p'))
  {
    p <- getPassword()
  }
  ewedb <- connect2postgres('115.146.84.135', db='ewedb',
                         user='gislibrary', p=p)
  dbSendQuery(ewedb, 'drop table airquality')
  load2postgres('airquality.csv','public', 'airquality', pguser =
                'gislibrary', ip = '115.146.84.135', db='ewedb', print = F)
  
  # from plyr
  require(plyr)
  head(baseball)
  write.csv(baseball, 'baseball.csv', row.names=F, na = "")
  load2postgres('baseball.csv','public', 'baseball', pguser =
                'gislibrary', ip = '115.146.84.135', db='ewedb', print = F)
  
#+end_src

*** R-load2postgres
#+name:load2postgres
#+begin_src R :session *R* :tangle R/load2postgres.r :exports none :eval no
################################################################
# name:load2postgres
# tools for loading data to postgres
# Joseph Guillame and Ivan Hanigan
# original by Joe 24/3/2009

# TO DO:
## set the vacuum automatically when printcopy=F
## on linux replace the 'type' command with 'cat'

# load_newtable_to_postgres = Convert to csv and load to postgres
# pk as either column names as they appear at the end or column indices

# inspired from
#odbc_dsn="pg"
#require(RODBC)
#con<-odbcConnect(odbc_dsn,"postgres","test",case="postgresql")
#sqlSave(con,data[0,],test=TRUE,verbose=TRUE)
#close(con)

# source file could be
#source_file=paste("E'", csvfilename,"'",sep="")


# if (!file.exists('C:/pgutils/psql.exe')) {
# dir.create('c:/pgutils')
# download.file("http://alliance.anu.edu.au/access/content/group/4e0f55f1-b540-456a-000a-24730b59fccb/pgutils.zip","c:/pgutils/pgutils.zip",mode="wb")
# unzip("c:/pgutils/pgutils.zip",exdir="C:/pgutils")
# }
# not working
# print('please download http://alliance.anu.edu.au/access/content/group/4e0f55f1-b540-456a-000a-24730b59fccb/pgutils.zip')

load2postgres <- function(inputfilepath,schema,tablename,pk=NULL,header=TRUE,printcopy=TRUE,sheetname="Sheet1",withoids=FALSE,pguser="username",db='databasename',ip='ipaddress',source_file="STDIN",datecol=NULL,nrowscsv=10000,pgpath=c('c:\\pgutils\\psql')){
  if (!require(RODBC)) install.packages('RODBC'); require(RODBC) # for getSqlTypeInfo
  table=paste(schema,".",tablename,sep="")
  
  ext<-substr(inputfilepath,nchar(inputfilepath)-2,nchar(inputfilepath))
  #print(ext)
  
  if (ext=="dbf"){
    require(foreign)
    data<-read.dbf(inputfilepath,as.is=TRUE)
    csvfilename=sub(".dbf",".csv",basename(inputfilepath))
    csvfilename=paste(getwd(),csvfilename,sep="/")
    write.csv(data,csvfilename,row.names=FALSE,na="")
  }
  else if (ext=="csv" || ext=="txt"){
    #or from csv originally
    csvfilename<-inputfilepath
    data<-read.csv(csvfilename,stringsAsFactors=FALSE,header=header,strip.white=TRUE,nrows=nrowscsv)
    names(data)<-gsub("\\.","_",names(data))
    names(data)<-gsub("_+","_",names(data))
  }
  else if (ext=="xls"){
    odbcf<-odbcConnectExcel(inputfilepath)
    data<-sqlFetch(odbcf,sheetname,as.is=TRUE)
    csvfilename=sub(".xls",".csv",basename(inputfilepath))
    csvfilename=paste(getwd(),csvfilename,sep="/")
    write.csv(data,csvfilename,row.names=FALSE,na="")
  }
  else print("Unknown extension")
  
  names(data)<-tolower(names(data))
  
  if (length(pk)>0) {
    if (class(pk) %in% c("integer","numeric")) pk=paste(names(data)[pk],collapse=",")
  }
  
  datatypes<-getSqlTypeInfo("PostgreSQL")
  datatypes["numeric"]<-"numeric"
  
  csvfilename=gsub("\\\\","\\\\\\\\",csvfilename)
  
  text=""
  text=paste(text,"CREATE TABLE ",table," (",sep="")
  columnnames<-names(data)
  
  #################################################################################
  
  if (length(pk)>0) {
    for (n in columnnames) {
      if (length(grep(n, datecol))>0) {
        text=paste(text,"\"",n,"\" date,\n",sep="")
      } else {
        #print(class(data[[n]]))
        if (is.null(class(data[[n]]))) cat("Missing datatype:",class(data[[n]]),"\n")
        text=paste(text,"\"",n,"\" ",datatypes[[class(data[[n]])]],",\n",sep="")
      }
    }
    text=paste(text,"CONSTRAINT \"",table,"_pkey\" PRIMARY KEY (",pk,")\n",sep="")
  }
  
  if (length(pk)==0) {
    for (n in columnnames[1:(length(columnnames)-1)]) {
      if (length(grep(n, datecol))>0) {
        text=paste(text,"\"",n,"\" date,\n",sep="")
      } else {
        #print(class(data[[n]]))
        if (is.null(class(data[[n]]))) cat("Missing datatype:",class(data[[n]]),"\n")
        text=paste(text,"\"",n,"\" ",datatypes[[class(data[[n]])]],",\n",sep="")
      }
    }
    
    n=columnnames[length(columnnames)]
    text=paste(text,"\"",n,"\" ",datatypes[[class(data[[n]])]],sep="")
    #\"
  }
  
  ###############################################################################
  if (withoids) text=paste(text,") WITH (OIDS=TRUE);\n",sep="")
  else text=paste(text,") WITH (OIDS=FALSE);\n",sep="")
  text=paste(text,"ALTER TABLE ",table," OWNER TO ",pguser,";\n",sep="")
  
  
  
  
  if (source_file=="STDIN") {
    if (header) text=paste(text,"COPY ",table," FROM ",source_file," CSV HEADER;\n",sep="")
    else text=paste(text,"COPY ",table," FROM ",source_file," CSV;\n",sep="")
    
    sink("sqlquery.txt")
    cat(text)
    sink()
    
    
    
 
    if(length(grep('linux',sessionInfo()[[1]]$os)) == 1)
     {
      os <- 'linux'
     } else {
      os <- 'windows'
     }
    if (printcopy & os == 'linux')
    {
      cat(paste('ok the CREATE TABLE and COPY statements have been constructed for this file and is in "sqlquery.txt", have a look and see if it is correct\nif it is ok and you have not set your password to be remembered in pgpass then paste this into a cmd prompt\n\n cat sqlquery.txt \"',csvfilename,'\" | \"',pgpath,'\" -h ',ip,' -U ',pguser,' -d ',db,'\n\n\notherwise you can run this directly from R\n\n system(\"cat sqlquery.txt \\"',csvfilename,'\\" | psql -h ',ip,' -U ',pguser,' -d ',db,'\")',sep=''),'\n')
      
      cat(paste("\n\nnow you probably should vaccuum the table\nVACUUM ANALYZE ",table,";\n",sep=""))
    } 
    if (!printcopy & os == 'linux')
    {
     
      system(paste('cat sqlquery.txt \"',csvfilename,'\" | psql -h ',ip,' -U ',pguser,' -d ',db,'',sep=''))
          
    }
    

    if (printcopy & os == 'windows')
    {
      cat(paste('ok the CREATE TABLE and COPY statements have been constructed for this file and is in "sqlquery.txt", have a look and see if it is correct\nif it is ok and you have not set your password to be remembered in pgAdmin then paste this into a cmd prompt\n\n type sqlquery.txt \"',csvfilename,'\" | \"',pgpath,'\" -h ',ip,' -U ',pguser,' -d ',db,'\n\n\notherwise you can run this directly from R\n\n system(\"type sqlquery.txt \\"',csvfilename,'\\" | \"',pgpath,'\" -h ',ip,' -U ',pguser,' -d ',db,'\")',sep=''),'\n')
      
      cat(paste("\n\nnow you probably should vaccuum the table\nVACUUM ANALYZE ",table,";\n",sep=""))
    } 
    if (!printcopy & os == 'windows')
    {
      sink('go.bat')
      cat(paste('type sqlquery.txt \"',csvfilename,'\" | \"',pgpath,'\" -h ',ip,' -U ',pguser,' -d ',db,'',sep=''))
      sink()
      shell('go.bat')
      file.remove('go.bat')
    }
    
    
  }
  
}

#+end_src

** load2postgres_raster
#+name:load2postgres_raster
#+begin_src R :session *R* :tangle R/load2postgres_raster.r :exports none :eval no
  ################################################################
  # name:load2postgres_raster
  load2postgres_raster <- function(filename, out_schema, out_table,  ipaddress = "115.146.84.135", u = "gislibrary", d = 'ewedb', pgisutils = "", srid = 4283, remove = TRUE)
  {
    # outname <- gsub('.tif',"", filename)
    # outname <- substr(outname, 1, nchar(outname) - 8)
    outname <- paste(out_schema, out_table, sep = ".")
    os <- LinuxOperatingSystem()
    if(os)
    {
     system(
    #        cat
            paste(pgisutils,"raster2pgsql -s ",srid," -I -C -M ",filename," -F ",outname," > ",outname,".sql", sep="")
            )
  
     system(
    #        cat
            paste("psql -h ",ipaddress," -U ",u," -d ",d," -f ",outname,".sql",
              sep = ""))
    } else {
      sink('raster2sql.bat')
      cat(paste(pgisutils,"raster2pgsql\" -s ",srid," -I -C -M ",filename," -F ",outname," > ",outname,".sql\n",sep=""))
  
      cat(
      paste(pgisutils,"psql\" -h ",ipaddress," -U ",u," -d ",d," -f ",outname,".sql",
      sep = "")
        )
      sink()
      system('raster2sql.bat')
      file.remove('raster2sql.bat')
    }
  
    if(remove)
      {
        file.remove(filename)
        file.remove(paste(outname, '.sql', sep =""))
      }
  }
  
#+end_src

** load2postgres_shp
#+name:load2postgres_shp
#+begin_src R :session *R* :tangle R/load2postgres_shp.r :exports none :eval no
  ################################################################
  
  load2postgres_shp <- function(filename, out_schema, out_table,  ipaddress = "115.146.84.135", u = "gislibrary", d = 'ewedb', pgisutils = "", srid = 4283, remove = TRUE)
  {
    outname <- paste(out_schema, out_table, sep = ".")
    os <- LinuxOperatingSystem()
    if(os)
    {
     system(
    #        cat
            paste(pgisutils,"shp2pgsql -s ",srid," -D ",filename," ",outname," > ",outname,".sql", sep="")
            )
  
     system(
    #        cat
            paste("psql -h ",ipaddress," -U ",u," -d ",d," -f ",outname,".sql",
              sep = ""))
    } else {
      sink('shp2sql.bat')
      cat(paste(pgisutils,"shp2pgsql\" -s ",srid," -D ",filename," ",outname," > ",outname,".sql\n",sep=""))
  
      cat(
      paste(pgisutils,"psql\" -h ",ipaddress," -U ",u," -d ",d," -f ",outname,".sql",
      sep = "")
        )
      sink()
      system('shp2sql.bat')
      file.remove('shp2sql.bat')
    }
  
    if(remove)
      {
        file.remove(filename)
        file.remove(paste(outname, '.sql', sep =""))
      }
  }
  
#+end_src

** make_ddixml
*** test-make_ddixml
#+name:test-make_ddixml
# tests/test-make_ddixml.r
#+begin_src R :session *R* :tangle no :exports none :eval no
  ################################################################
  # name:test-make_ddixml
  source("R/make_ddixml.r")
  require(swishdbtools)
      if(!exists('p'))
      {
        pwd <- getPassword(remote=T)
      }
  
      ch <- connect2oracle('115.146.93.225', db="DDIINDEXDB", p = pwd)
  
  stdydscr <- dbGetQuery(ch,
                     "select * from stdydscr where idno = 'R_DATASETS'")
  file <- dbGetQuery(ch,
                     "select * from filedscr where idno = 'R_DATASETS'")
  file
  for(fid in file$FILEID)
    {
  #    fid = file$FILEID[1]
      datadscr <- dbGetQuery(ch,
                            paste("select * from datadscr where fileid = '",fid,"'",
                            sep = "")
                            )
  
  #datadscr
      file_i <- file[file$FILEID==fid,]
    make_ddixml(s = stdydscr, f=file_i, d=datadscr, writeXML= T)
    }
  
#+end_src
*** R-make_ddixml
#+name:make_ddixml
#+begin_src R :session *R* :tangle R/make_ddixml.r :exports none :eval no
  ################################################################
  # name:make_ddixml
  make_ddixml <- function(s,f,d, writeXML = F){
    if (!require(sqldf)) install.packages('sqldf')
    require(sqldf)
  
    abbreviation=toupper(f$IDNO)
    print(abbreviation) 
    # get study data
    stdyDscr=s
    head(t(stdyDscr))
    tail(t(stdyDscr))
    
    # get othrstdymat
    # othrstdymat <- sqlQuery(ch,
    # sprintf("
    # select t1.titl, t2.*
    # from stdyDscr t1
    # join othrstdymat t2
    # on t1.idno=t2.idno
    # where t1.idno='%s'
    # ",abbreviation)
    # ,stringsAsFactor=F)
    
    # if(nrow(othrstdymat)>0){
    # stdyDscr$ABSTRACT <- paste(stdyDscr$ABSTRACT,
    # '\n\nRELATED MATERIAL:\n',
    # paste(othrstdymat$RELPUBL[!is.na(othrstdymat$RELPUBL)],collapse='\n ',sep=''),
    # '\n\nRELATED NCEPH STUDIES:\n',
    # paste(othrstdymat$RELSTDYID[!is.na(othrstdymat$RELSTDYID)],collapse='\n ',sep='')
    # ,sep='')
    # }
    # cat(stdyDscr$ABSTRACT)
    
    # TASK if files then 'http://alliance.anu.edu.au/access/content/group/bf77d6fc-d1e1-401c-806a-25fbe06a82d0/ddiindex-nceph/',tolower(abbreviation),'_',fileid,'.html'
    
    # get file data
    fileDscr=f
    
    head(fileDscr)
    fileDscr[,1:4]
    
    
    if(nrow(fileDscr)==0){
      fileDscr=data.frame(t(c(1,abbreviation,stdyDscr$TITL,'Metadata','','','','','','NCEPH','NCEPH Restricted','','','','')),stringsAsFactors =F)
      names(fileDscr) = c('FILEID','IDNO','FILENAME','FILETYPE','PROCSTAT','SPECPERMFILE','DATEARCHIVED','DATEDESTROY','FILEDSCR','FILELOCATION','NOTES','REQID','PUBLISHDDI','BACKUPVALID','DATEBACKUPVALID')
    } 
    # get variable details
    
    #for(j in 1:nrow(fileDscr)){
    j=1
    fileDscrJ= fileDscr[j,]
    names(fileDscrJ)=toupper(names(fileDscrJ))
    filej=fileDscr[j,1]
    filej
    dataDscr=d
    head(dataDscr)
    dataDscr$PKEY <- seq(1:nrow(dataDscr))
    dataDscr<- dataDscr[,c(5,1:4)]
    #V1="V1"
    #vardesc1="variable description stuff"
    #varlabels1="theNameOfTheVariable"
    if(nrow(dataDscr)==0) {
      variablesList=paste("<var ID='V1' name ='",fileDscrJ$FILENAME,"'>
                          <location></location>
                          <labl>
                          <![CDATA[
                          ",fileDscrJ$NOTES,"
                          ]]>
                          </labl>
                          <qstn></qstn>
                          <qstnLit></qstnLit>
                          <invalrng></invalrng>
                          <range></range>
                          <item></item>
                          <notes></notes>
                          <universe></universe>
                          <sumStat></sumStat>
                          <txt></txt>
                          <catgryGrp></catgryGrp>
                          <labl></labl>
                          <catStat></catStat>
                          <catgry></catgry>
                          <catValu></catValu>
                          <labl></labl>
                          <txt></txt>
                          <catStat></catStat>
                          <concept></concept>
                          <derivation></derivation>
                          <drvdesc></drvdesc>
                          <varFormat></varFormat>
                          <notes>
                          <![CDATA[
                          ",fileDscrJ$NOTES,"             
                          ]]>
                          </notes>
                          </var>",sep=""
      )
    } else {
      
      for(i in 1:nrow(dataDscr)){
        
        #i=2
        if (i == 1) {
          variablesList=paste("<var ID='V",i,"' name ='",as.character(dataDscr[i,'LABL']),"'>
                              <location></location>
                              <labl>
                              <![CDATA[
                              ",dataDscr[i,'NOTES'],"
                              ]]>
                              </labl>
                              <qstn></qstn>
                              <qstnLit></qstnLit>
                              <invalrng></invalrng>
                              <range></range>
                              <item></item>
                              <notes></notes>
                              <universe></universe>
                              <sumStat></sumStat>
                              <txt></txt>
                              <catgryGrp></catgryGrp>
                              <labl></labl>
                              <catStat></catStat>
                              <catgry></catgry>
                              <catValu></catValu>
                              <labl></labl>
                              <txt></txt>
                              <catStat></catStat>
                              <concept></concept>
                              <derivation></derivation>
                              <drvdesc></drvdesc>
                              <varFormat></varFormat>
                              <notes>
                              <![CDATA[
                              ",dataDscr[i,'NOTES'],"
                              ]]>
                              </notes>
                              </var>",sep=""
          )
        } 
        else {
          variablesList=rbind(variablesList,
                              paste("<var ID='V",i,"' name ='",dataDscr[i,'LABL'],"'>
                                    <location></location>
                                    <labl>
                                    <![CDATA[
                                    ",dataDscr[i,'NOTES'],"
                                    ]]>
                                    </labl>
                                    <qstn></qstn>
                                    <qstnLit></qstnLit>
                                    <invalrng></invalrng>
                                    <range></range>
                                    <item></item>
                                    <notes></notes>
                                    <universe></universe>
                                    <sumStat></sumStat>
                                    <txt></txt>
                                    <catgryGrp></catgryGrp>
                                    <labl></labl>
                                    <catStat></catStat>
                                    <catgry></catgry>
                                    <catValu></catValu>
                                    <labl></labl>
                                    <txt></txt>
                                    <catStat></catStat>
                                    <concept></concept>
                                    <derivation></derivation>
                                    <drvdesc></drvdesc>
                                    <varFormat></varFormat>
                                    <notes>
                                    <![CDATA[
                                    ",dataDscr[i,'NOTES'],"
                                    ]]>
                                    </notes>
                                    </var>",sep=""))
        }
        }
      cat(variablesList)
        }
    
    # get keywords
    keywords=abbreviation
    
    keywords=c(keywords,
               unlist(strsplit(dataDscr$LABL,"_")),
               unlist(strsplit(fileDscrJ$FILENAME,"_"))
    )
    
    keywords=data.frame(toupper(keywords))
    names(keywords)='keywords'
    keywords=sqldf('select distinct keywords from keywords',drv='SQLite')
    
    for(i in 1:nrow(keywords)){
      #i=2
      if (i == 1) {
        keywordslist=paste("<keyword>
                           <![CDATA[  
                           ",keywords[i,1],"
                           ]]>
                           </keyword>",sep="")
      } else {
        keywordslist=rbind(keywordslist,
                           paste("<keyword>
                                 <![CDATA[  
                                 ",keywords[i,1],"
                                 ]]>
                                 </keyword>",sep="")
                           )
      }
      }
    cat(keywordslist)
    
    #################################################################################
    # save to an xml
    
    names(stdyDscr)=tolower(names(stdyDscr))
    attach(stdyDscr)
    names(fileDscr)=tolower(names(fileDscr))
    names(fileDscrJ)=tolower(names(fileDscrJ))
    attach(fileDscrJ)
    
    
    
    
    xml=paste("
              <codeBook version=\"1.2.2\" ID=\"",tolower(abbreviation),"_",fileDscrJ$fileid,"\">
              <docDscr>
              <citation>
              <titlStmt>
              <titl>
              <![CDATA[  
              ",paste(toupper(abbreviation),filename,sep='_'),"
              ]]> 
              </titl>
              <IDNo>
              <![CDATA[  
              ",tolower(abbreviation),"_",fileDscrJ$fileid,"
              ]]> 
              </IDNo>
              </titlStmt>
              <prodStmt>
              <producer>
              <![CDATA[  
              ",producer,"
              ]]>
              </producer>
              <copyright>
              <![CDATA[  
              ",copyright,"
              ]]>
              </copyright>
              <prodDate date='",as.Date(proddatedoc,'%d/%M/%Y'),"'>'",as.Date(proddatedoc,'%d/%M/%Y'),"'
              </prodDate>
              <software></software>
              </prodStmt>
              <verStmt>
              <version></version>
              <notes></notes>
              </verStmt>
              <biblCit>
              <![CDATA[  
              ",biblcitdoc,"
              ]]>
              </biblCit>
              </citation>
              <notes></notes>
              </docDscr>
              <stdyDscr >
              <citation >
              <titlStmt>
              <titl>
              <![CDATA[  
              ",paste(toupper(abbreviation),filename,sep='_'),"
              ]]>
              </titl>
              <IDNo>
              <![CDATA[  
              ",tolower(abbreviation),"_",fileDscrJ$fileid,"
              ]]>
              </IDNo>
              </titlStmt>
              <rspStmt>
              <AuthEnty>
              <![CDATA[  
              ",authenty,"
              ]]>
              </AuthEnty>
              <othId></othId>
              </rspStmt>
              <prodStmt>
              <producer></producer>
              <copyright>
              <![CDATA[  
              ",copyright,"
              ]]>
              </copyright>
              <prodDate>
              <![CDATA[  
              ",proddatestdy,"
              ]]>
              </prodDate>
              <fundAg>
              <![CDATA[  
              ",fundag,"
              ]]>          
              </fundAg>
              </prodStmt>
              <distStmt>
              <distrbtr>
              <![CDATA[  
              ",distrbtr,"
              ]]>  
              </distrbtr>
              <contact>
              <![CDATA[  
              ",distrbtr,"
              ]]>  
              </contact>
              <distDate></distDate>
              </distStmt>
              <serStmt>
              <serName>
              <![CDATA[  
              ",sername,"
              ]]>  
              </serName>
              </serStmt>
              <verStmt>
              <version>
              <![CDATA[  
              ",version,"
              ]]>  
              </version>
              <notes></notes>
              </verStmt>
              <biblCit>
              <![CDATA[  
              ",biblcitstdy,"
              ]]>  
              </biblCit>
              </citation >
              <stdyInfo>
              <subject>
              ",paste(t(keywordslist),collapse="\n"),"
              <topcClas>
              <![CDATA[ 
              ",stdyDscr$notes," 
              ]]> 
              </topcClas>
              <topcClas>
              <![CDATA[  
              ",titl,"
              ]]> 
              </topcClas>
              </subject>
              <abstract>
              <![CDATA[
              ",
              
              paste("\n\nSTUDY TITLE:\n",titl,
                    "\n\nFILE DESCRIPTION:\n",fileDscr$filetype[j],"\n",fileDscr$filedscr[j],"\n",fileDscr$notes[j],
                    paste("\nMETADATA DOCUMENTS:
                          http://alliance.anu.edu.au/access/content/group/bf77d6fc-d1e1-401c-806a-25fbe06a82d0/ddiindex-nceph/",fileDscrJ$idno,'_',fileDscrJ$fileid,'.html (and xml)',sep=''),
                    "\n\nSTUDY DESCRIPTION:\n",abstract,sep="",collapse="\n")
              
              ,"
              ]]>
              </abstract>
              <sumDscr>
              <timePrd>
              <![CDATA[
              ",timeprd,"           
              ]]> 
              </timePrd>
              <collDate>
              <![CDATA[
              ",colldate," 
              ]]>
              </collDate>
              <nation></nation>
              <geogCover>
              <![CDATA[
              ",geogcover,"        
              ]]>
              </geogCover>
              <geogUnit>
              <![CDATA[
              ",geogunit," 
              ]]> 
              </geogUnit>
              <anlyUnit>
              <![CDATA[
              ",anlyunit,"
              ]]> 
              </anlyUnit>
              <universe>
              <![CDATA[
              ",universe,"
              ]]> 
              </universe>
              <dataKind>
              <![CDATA[
              ",datakind,"
              ]]>
              </dataKind>
              </sumDscr>
              <notes></notes>
              </stdyInfo>
              <method>
              <dataColl>
              <timeMeth></timeMeth>
              <dataCollector></dataCollector>
              <sampProc></sampProc>
              <collMode></collMode>
              <sources></sources>
              <weight></weight>
              <cleanOps>
              <![CDATA[
              ",cleanops,"
              ]]>
              </cleanOps>
              </dataColl>
              <notes></notes>
              </method>
              <dataAccs>
              <setAvail>
              <collSize></collSize>
              <fileQnty></fileQnty>
              </setAvail>
              <useStmt>
              <confDec>
              <![CDATA[
              ",confdec,"
              ]]>
              </confDec>
              <specPerm>
              <![CDATA[
              ",paste("STUDY PERMISSIONS:\n",specperm,"\nFILE PERMISSIONS:\n",fileDscrJ$specpermfile,sep=""),"
              ]]>
              </specPerm>
              <restrctn></restrctn>
              </useStmt>
              </dataAccs>
              <notes>
              <![CDATA[
              ",notes," 
              ]]>
              </notes>
              </stdyDscr >
              <fileDscr>
              <fileTxt>
              <fileName>
              <![CDATA[
              ",paste(tolower(abbreviation),filename,sep='_'),"
              ]]>
              </fileName>
              <dimensns>
              <caseQnty></caseQnty>
              <varQnty></varQnty>
              <logRecL></logRecL>
              <recPrCas></recPrCas>
              </dimensns>
              <fileType>
              <![CDATA[
              ",filetype,"
              ]]>
              </fileType>
              <ProcStat>
              <![CDATA[
              ",'processing description suppressed',"
              ]]>
              </ProcStat>
              </fileTxt>
              <notes>
              <![CDATA[
              ",notes," 
              ]]>
              </notes>
              </fileDscr>
              <dataDscr>
              <varGrp></varGrp>
              <labl></labl>
              <notes></notes>
              ",paste(t(variablesList),collapse="\n"),"
              </dataDscr>
              </codeBook>
              ",sep="")
    #    ",paste(t(othermatlist),collapse="\n"),"
    detach(stdyDscr)
    detach(fileDscrJ)
    
  #  cat(xml)
  if(writeXML)
  {
    outdir <- getwd()
    write.table(xml,sprintf("%s/%s%s%s.xml",outdir,tolower(abbreviation),"_",fileDscrJ$fileid),row.names=F,col.names=F,quote=F)
  } else {
  return(xml)
  }  
  }
  
#+end_src
** pgListTables
*** test-pgListTables
#+name:pgListTables
#+begin_src R :session *R* :tangle tests/test-pgListTables.r :exports none :eval no
  source("../R/pgListTables.r")
  source("../R/connect2postgres2.r")
  source("../R/connect2postgres.r")
  source("../R/get_pgpass.r")
  source("../R/getPassword.r")
  source("../R/get_passwordTable.r")
  source("../R/LinuxOperatingSystem.r")
  
  ch <- connect2postgres2("ewedb")
  test_that("lists postgis table", {
    expect_that(nrow(pgListTables(conn=ch, schema="public",
                                  pattern="spatial_ref_sys")) == 1,
                 is_true())
     expect_that(nrow(pgListTables(conn=ch, schema='public',
                                   pattern='elmoreJames')) == 0,
                 is_true())
  })
  
  
  # dev tests
  ##  tbls <- pgListTables(conn=ch, schema='public', pattern='spatial_ref_sys')
  ##  nrow(tbls) == 1
  ## #
  ##  tbls <- pgListTables(conn=ch, schema='public', pattern='elmoreJames')
  ##  nrow(tbls)
  # tbls
  # pgListTables(conn=ch, schema='public', pattern='dbsize')
  # tables <- dbGetQuery(ch, 'select   c.relname, nspname, c.relkind
  #                        FROM pg_catalog.pg_class c
  #                        LEFT JOIN pg_catalog.pg_namespace n
  #                      ON n.oid = c.relnamespace
  #                      where c.relkind IN (\'r\',\'\', \'v\') ')
  #
  # table(tables$relkind)
  # # S     c     i     r     t     v
  # # 20509    11 61649 20609 20527   109
  
#+end_src
*** R-pgListTables
#+name:pgListTables
#+begin_src R :session *R* :tangle R/pgListTables.r :exports none :eval no
  ################################################################
  # name:pgListTables
  pgListTables <- function(conn, schema, pattern = NA)
  {
    if(!is.na(pattern))
    {
      tables <- dbGetQuery(conn,
                           paste("select   c.relname, nspname
                         FROM pg_catalog.pg_class c
                         LEFT JOIN pg_catalog.pg_namespace n
                         ON n.oid = c.relnamespace
                         where (c.relkind IN ('r','','v'))
                          and (nspname = '",schema,"' and relname = '",pattern,"')", sep = "")
      )
    } else {
      tables <- dbGetQuery(conn,
                           paste("select   c.relname, nspname
                         FROM pg_catalog.pg_class c
                         LEFT JOIN pg_catalog.pg_namespace n
                         ON n.oid = c.relnamespace
                         where (c.relkind IN ('r','','v'))
                          and (nspname = '",schema,"')", sep = "")
      )
    }
  
  #   tables <- tables[grep(schema,tables$nspname),]
  #    tables <- tables[grep(pattern, tables$relname),]
    if(nrow(tables) > 0)
      {
        tables <- tables[order(tables$relname),]
      }
  
    return(tables)
  }
  
#+end_src
*** man-pgListTables
#+name:pgListTables
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:pgListTables

#+end_src

** postgis_join_attributes
*** test-postgis_join_attributes
#+name:postgis_join_attributes
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:postgis_join_attributes

#+end_src
*** R-postgis_join_attributes
#+name:postgis_join_attributes
#+begin_src R :session *R* :tangle R/postgis_join_attributes.r :exports none :eval no
  ################################################################
  # name:postgis_join_attributes
  
  postgis_join_attributes <- function(channel,
      tablename, zones, into, zonesid.x, zonesid.y = zones.x, simplify = 0.02, eval = FALSE, postgis_version = 1.5){
      ## channel = ch
      ## zones = 'abs_poa.nswpoa01'
      ## tablename = 'qcmap_rain'
      ## variable = 'totalssum'
      ## into = paste(tablename,1,sep = "")
      ## zonesid = 'poa_code'
      ## simplify = 0.02
      ## tidy = FALSE
      # test <- try(dbGetQuery(ch,paste("select ",zonesid," from ",into," limit 1;", sep = "")))
      # if(length(test) > 0){
      #   dbSendQuery(ch,paste("drop table ", into))
      # }
     if(length(grep("\\.",into)) == 0)
      {
        schema <- "public"
        table <- into
      } else {
        schema <- strsplit(into, "\\.")[[1]][1]
        table <- strsplit(into, "\\.")[[1]][2]
      }
    
  
  #                cat(
           sql <-  paste("
                   select t1.*,
                   st_simplify(the_geom, ",simplify,") as the_geom
                   into ",schema,".",table,"
                   from ",tablename," t1
                   join ",zones," t2
                   on ",zonesid.x," =
                    ",zonesid.y,";
  
                   alter table ",schema,".",table," add column gid serial primary key;",
                   sep = "")
  
      if(postgis_version != 2)
        {
           fixgeom <- paste("INSERT INTO geometry_columns(f_table_catalog, f_table_schema, f_table_name, f_geometry_column, coord_dimension, srid, \"type\")
   SELECT '', '",schema,"', '",table,"', 'the_geom', ST_CoordDim(the_geom), ST_SRID(the_geom), GeometryType(the_geom)
   FROM ",schema,".",table," LIMIT 1;", sep = "")
          sql <- paste(sql,fixgeom,sep = "\n")
        }
  
      if(eval)
      {
      dbSendQuery(ch, sql)
      dbSendQuery(ch, paste("grant select on",into,"to public_group"))
      } else {
      return(sql)
      }
    #  shp <- readOGR2(hostip = NA, user = NA, db = NA, layer = NA, p = p)
      ## if(tidy == TRUE){
      ##   dbSendQuery(ch,'drop table temp;')
      ##   dbSendQuery(ch,'drop table temp1;')
      ## }
  
    }
  
#+end_src
*** man-postgis_join_attributes
#+name:postgis_join_attributes
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:postgis_join_attributes

#+end_src

** postgis_raster_extract
*** test-postgis_raster_extract
#+name:postgis_raster_extract
#+begin_src R :session *R* :tangle no :exports none :eval no
  ################################################################
  # name:postgis_raster_extract
  postgis_raster_extract(
    conn = ch
    ,
    x = "abs_cd"
    ,
    y
    ,
    fun = NA
    ,
    into = FALSE
    ,
    eval = FALSE
    )
  
#+end_src
*** R-postgis_raster_extract
#+name:postgis_raster_extract
#+begin_src R :session *R* :tangle R/postgis_raster_extract.r :exports none :eval no
  ################################################################
  
  postgis_raster_extract <- function(conn, x, y, fun = NA, eval = FALSE, zone_label, value_label = NA, into = FALSE)
  {
  # assumptions
  out_schema <- "public"
  
  if(is.data.frame(y))
    {
      # assume location is from gGeoCode2, dataframe with address,  lat, long
      # assume gda94
      srid <- 4283
  y <- paste("(
  select cast('",y$address,"' as text ) as location, st_GeomFromText(
                       'POINT('||
                       ",y$long," ||
                       ' '||
                       ",y$lat," ||')'
                       ,",srid,") as the_geom
  )", sep = "")
    }
  
  #                   into ",value_label,"_join_", pwcName,
  sql <- paste("SELECT pt.",zone_label,", cast('",x,"' as text) as raster_layer,
  ST_Value(rt.rast, pt.the_geom) as ",value_label,
  "\nFROM ",x," rt,
  ",y," pt
  WHERE ST_Intersects(rast, the_geom)
  ", sep ="")
  
  
  if(into)
  {
    out_table <- paste(y, "_extract_",value_label, sep = "")
    tblList <- pgListTables(conn, schema=out_schema)
    recordIndex <- which(tblList$relname == out_table)
    if(length(recordIndex) == 0)
    {
      sql <- gsub("\nFROM", paste("\nINTO ", out_schema, ".", out_table , "\nFROM ", sep = ""), sql)
    } else {
      sql_insert <- paste("INSERT INTO ", out_schema, ".", out_table, " (", zone_label, ", raster_layer, ", value_label, ")", sep = "")
      sql <- paste(sql_insert, sql, sep = "\n")
    }
  
  }
  
  return(sql)
  #dbSendQuery(conn,
  #
  
  }
  
#+end_src
*** man-postgis_raster_extract
#+name:postgis_raster_extract
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:postgis_raster_extract

#+end_src
** points2geom
*** test-points2geom
#+name:points2geom
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:points2geom

#+end_src
*** R-points2geom
#+name:points2geom
#+begin_src R :session *R* :tangle R/points2geom.r :exports none :eval no
  ################################################################
  # name:points2geom
  points2geom <- function(schema,tablename,col_lat,col_long, srid="4283"){
    table <- sprintf("%s.%s",schema,tablename)
  
    sql1 <- sprintf(
      "SELECT AddGeometryColumn('%s', '%s', 'the_geom', %s, 'POINT', 2);\n",
      schema,tablename, srid)
  
    sql2 <- sprintf(
      "ALTER TABLE %s ADD CONSTRAINT geometry_valid_check CHECK (st_isvalid(the_geom));\n" ,
      table)
  
    sql3 <- sprintf("
                UPDATE %s
                SET the_geom=st_GeomFromText(
                'POINT('||
                %s ||
                ' '||
                %s ||')'
                ,%s);\n",table,col_long,col_lat, srid)

   sql4 <- paste("alter table ",schema,".",tablename," add column gid serial primary key;
                 ALTER TABLE ",schema,".",tablename," ALTER COLUMN the_geom SET NOT NULL;
                 CREATE INDEX ",tablename,"_gist on ",schema,".",tablename," using GIST(the_geom);
                 ALTER TABLE ",schema,".",tablename," CLUSTER ON ",tablename,"_gist;
                 ", sep = "")
                 
  
    sql <- paste(sql1, sql2, sql3, sql4, sep = "\n")
  }
  
#+end_src
*** man-points2geom
#+name:points2geom
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:points2geom

#+end_src

** readGDAL2
*** test-readGDAL2
#+name:readGDAL2
#+begin_src R :session *R* :tangle tests/test-readGDAL2.r :exports none :eval no
  ################################################################
  # name:readGDAL2
  require(swishdbtools)
  pwd <- getPassword()
  rast <- readGDAL2(hostip="115.146.84.135",user="gislibrary",
              db="ewedb",schema = "awap_grids",table= "maxave_20130108",p = pwd)
  
  image(rast)
  
#+end_src
*** R-readGDAL2
#+name:readGDAL2
#+begin_src R :session *R* :tangle R/readGDAL2.r :exports none :eval no
  ################################################################
  # name:readGDAL2
  readGDAL2 <- function(hostip=NA,user=NA,db=NA, schema=NA, table=NA, p = NA)
  {
    sql <-
      paste("PG:host=",hostip," port=5432 dbname='",db,"' user='",user,"' password='",p,"' schema='",schema,"' table=", table,
              sep = "")
  
    r <- readGDAL(sql)
    return(r)
  }
  
#+end_src
*** man-readGDAL2
#+name:readGDAL2
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:readGDAL2

#+end_src

** readOGR2
*** test-readOGR2
#+name:readOGR2
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:readOGR2

#+end_src
*** R-readOGR2
#+name:readOGR2
#+begin_src R :session *R* :tangle R/readOGR2.r :exports none :eval no
  ################################################################
  # name:readOGR2
  readOGR2 <- function(hostip=NA,user=NA,db=NA, layer=NA, p = NA) {
   # NOTES
   # only works on Linux OS
   # returns uninformative error due to either bad connection or lack of record in geometry column table.  can check if connection problem using a test connect?
   # TODO add a prompt for each connection arg if isna
   if (!require(rgdal)) install.packages('rgdal', repos='http://cran.csiro.au'); require(rgdal)
   if(is.na(p)){ 
   pwd=readline('enter password (ctrl-L will clear the console after): ')
   } else {
   pwd <- p
   }
   shp <- readOGR(sprintf('PG:host=%s
                           user=%s
                           dbname=%s
                           password=%s
                           port=5432',hostip,user,db,pwd),
                           layer=layer)
  
   # clean up
   rm(pwd)
   return(shp)
   }
  
#+end_src
*** man-readOGR2
#+name:readOGR2
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:readOGR2

#+end_src

** shp2pgis
*** test-shp2pgis
#+name:shp2pgis
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:shp2pgis

#+end_src
*** R-shp2pgis
#+name:shp2pgis
#+begin_src R :session *R* :tangle R/shp2pgis.r :exports none :eval no
  ################################################################
  # name:shp2pgis
  # windows version.  creates a .bat file and prints a SQL command to run on the database once completed
  shp2pgis <- function(infile, d='postgis', u='postgres',
                       host='localhost', srid=4283, schema='public', os='linux',
                       pgutils = 'C:\\pgutils\\'){
    if(os == 'linux'){
    cat('in a terminal run:\n\n')
    cat(paste("shp2pgsql -s ",srid," -D ",infile,".shp ",schema,".",infile," > ",infile,".sql",sep=""),"\n")
    cat(paste("psql  -d ",d," -U ",u," -W -h ",host," -f ",infile,".sql",sep=""),"\n")
  
    } else {
    cat(paste("\"",pgutils,"shp2pgsql\" -s ",srid," -D %1.shp ",schema,".%1 > %1.sql",sep=""),"\n")
    cat(paste("\"",pgutils,"psql\"  -d ",d," -U ",u," -W -h ",host," -f %1.sql",sep=""),"\n")
    cat('copy these two lines to make your batch file with the name doshp.bat\n\n')
    cat('now in the cmd line run:\n\n')
    cat(paste("doshp.bat ",infile,sep=""))
    }
  
    cat('\n\nOnce uploaed to postgres you may want to run:\n\n')
    cat(paste("\n\nCREATE INDEX idx_",infile,"_the_geom ON ",schema,".",infile," USING gist(the_geom);\n",sep=""))
    cat(paste("VACUUM ANALYZE ",schema,".",infile,";\n",sep=""))
  
    cat(paste("CREATE INDEX \"",infile,"_gist\"
              ON ",schema,".",infile,"
              USING gist
              (the_geom);
              ALTER TABLE ",schema,".",infile," CLUSTER ON \"",infile,"_gist\";\n",sep=""))
  
  
    if (srid!=4283){
      cat(
        sprintf("SELECT AddGeometryColumn('%s','%s','gda94_geom',4283,'MULTIPOLYGON',2);
                ALTER TABLE %s.\"%s\" DROP CONSTRAINT enforce_geotype_gda94_geom;
                UPDATE %s.\"%s\" SET gda94_geom=ST_Transform(the_geom,4283);",
                tolower(schema),tolower(infile),tolower(schema),tolower(infile),tolower(schema),tolower(infile))
      )
    }
  
  
  }
  
#+end_src
*** man-shp2pgis
#+name:shp2pgis
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:shp2pgis

#+end_src

** DEPRECATED sql_insert
** sql_subset_into
*** test-sql_subset_into
#+name:test-sql_subset_into
# tests/test-sql_subset_into.r
#+begin_src R :session *R* :tangle no :exports none :eval no
  source("R/connect2postgres.r")
  source("R/sql_subset.r")
  source("R/sql_subset_into.r")
  source("R/pgListTables.r")
  
  ch <- connect2postgres('115.146.84.135', db='ewedb', user='gislibrary', p='gislibrary')
  sql_subset_into(ch, 'dbsize',into_table='temp101', select = '*', eval=T)
  sql_subset(ch, 'temp101', eval = T)
  dbSendQuery(ch, 'drop table temp101')
  
#+end_src


*** R-sql_subset_into
#+name:sql_subset_into
#+begin_src R :session *R* :tangle R/sql_subset_into.r :exports none :eval no
  sql_subset_into <- function(conn, x, ..., into_schema = "public", into_table, eval = FALSE, drop = TRUE)
  {
    sql <- sql_subset(ch, x=x, ..., eval=F)
    sql <- gsub('from', paste("into ", into_schema, ".", into_table, "\nfrom ", sep = ""), sql)
    if(eval)
    {
      exists <- pgListTables(conn, into_schema, into_table)
      if(nrow(exists) > 0 & drop)
        {
          dbSendQuery(conn, paste("drop table ", into_schema, ".",
                                  into_table, sep =""))
        } else if (nrow(exists) > 0 & !drop)
          {
            stop("Table exists. Aborting.")
          }
    
      dbSendQuery(conn, sql)
      #dat <- dbGetQuery(conn, paste("select * from ", into_schema, ".", into_table, sep = ""))
      #return(dat)
    } else {
      return(sql)
    }
  }
    
#+end_src

** sql_subset
*** test-sql_subset.r
#+name:test-sql_subset.r
# tests/test-sql_subset.r
#+begin_src R :session *R* :tangle no :exports none :eval no
  
  ## install.packages("~/tools/swishdbtools_1.1_R_x86_64-pc-linux-gnu.tar.gz", repos = NULL, type = "source")
  require(swishdbtools)
  ##  ch <- connect2postgres('localhost', db='django', user='gislibrary', p='gislibrary')
  ## test_that('postgis data exists', {
  ##   expect_that(is.character(sqlquery_select(conn=ch, select='srid, srtext',x='spatial_ref_sys', limit = 2, subset = "srid = 4283", eval = F)), is_true())
  ##   expect_that(nrow(sqlquery_select(conn=ch, select='srid, srtext',x='spatial_ref_sys', limit = 2, subset = "srid = 4283", eval = T))==1, is_true())
  ## })
  
  #
  # dev tests
  source("R/sql_subset.r")
  source("R/pgListTables.r")
  if(!exists('p'))
  {
    p <- getPassword()
  }
   ewedb <- connect2postgres('115.146.84.135', db='ewedb', user='gislibrary', p=p)
   sql <- sql_subset(conn=ewedb, x='public.spatial_ref_sys',
                     subset = "srid = 4283", select='srid, srtext',
                     limit = 2, eval = T, check = T)
  ## cat(sql) # if eval=F
   nrow(sql)==1 # if eval=T
  
  #sql_subset(ewedb, 'airquality', 'Temp > 80', 'Ozone, Temp', eval = T,
  #           limit = 6)
  sql_subset(ewedb, 'dbsize', select = '*', eval=T)
  dbSendQuery(ewedb, 'drop table temp101')
  sql_subset(ewedb, 'dbsize', select = '*', eval=T)
  
#+end_src
*** R-sql_subset.r
#+name:sql_subset
#+begin_src R :session *R* :tangle R/sql_subset.r :exports none :eval no
  ################################################################
  # name:sqlquery_select
  
  sql_subset <- function(conn, x, subset = NA, select = "*",
                              limit = -1, eval = FALSE, check = T)
  {
    # assume ch exists
    if(length(grep("\\.",x)) == 0)
      {
        schema <- "public"
        table <- x
      } else {
        schema <- strsplit(x, "\\.")[[1]][1]
        table <- strsplit(x, "\\.")[[1]][2]
      }
  
  
    if(check)
      {
      exists <- pgListTables(conn, schema, table)
      if(nrow(exists) == 0)
      {
        stop("Table doesn't exist.")
      }
  
      }
  
  
    if(check & select=="*")
      {
        select <- names(
                       dbGetQuery(conn,
                        paste("select ", select, " from ",
                        schema, ".",
                        table, " limit 1",
                        sep = ""))
                       )
        select <- paste(select, collapse = ", ", sep = "")
      } 

    sqlquery <- paste("select ", select, "\nfrom ", schema, ".",
                      table, "\n",
                      sep = "")
  
    if(!is.na(subset))
      {
        sqlquery <- paste(sqlquery, "where ", subset, "\n", sep = "")
      }
  
    if(limit > 0)
      {
        sqlquery <- paste(sqlquery, "limit ", limit, "\n", sep = "")
      }
  
    if(eval)
      {
        dat <- dbGetQuery(conn,sqlquery)
        return(dat)
      } else {
        return(sqlquery)
      }

  
  }
  
#+end_src

*** man-sql_subset.Rd
#+name:sql_subset
#+begin_src R :session *R* :tangle man/sql_subset.Rd :exports none :eval no
\name{sql_subset}
\alias{sql_subset}
%- Also NEED an '\alias' for EACH other topic documented here.
\title{
sql_subset
}
\description{
Constructs an SQL query for a postgres database. Modelled on the base R function 'subset'.
}
\usage{
sql_subset(conn, x, subset, select, schema, limit, eval)
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{conn}{
%%     ~~Describe \code{remote} here~~
database connection
}
 \item{x}{
%%     ~~Describe \code{remote} here~~
the table name
}
 \item{subset}{
%%     ~~Describe \code{remote} here~~
the SQL 'where' statement
}
 \item{select}{
%%     ~~Describe \code{remote} here~~
which variables to include
}
 \item{schema}{
%%     ~~Describe \code{remote} here~~
the schema that has the table in it
}
 \item{limit}{
%%     ~~Describe \code{remote} here~~
limit, often useful for debugging
}
 \item{eval}{
%%     ~~Describe \code{remote} here~~
evaluate the query on the database?
}
}
\details{
%%  ~~ If necessary, more details than the description above ~~
}
\value{
%%  ~Describe the value returned
%%  If it is a LIST, use
%%  \item{comp1 }{Description of 'comp1'}
%%  \item{comp2 }{Description of 'comp2'}
%% ...
}
\references{
%% ~put references to the literature/web site here ~
}
\author{
ivanhanigan
}
\note{
%%  ~~further notes~~
}

%% ~Make other sections like Warning with \section{Warning }{....} ~

\seealso{
%% ~~objects to See Also as \code{\link{help}}, ~~~
}
\examples{
ch <- connect2postgres('115.146.84.135', db='ewedb',
                       user='gislibrary', p='gislibrary')
sql <- sql_subset(conn=ch, x='spatial_ref_sys',
                  subset = "srid = 4283", select='srid, srtext',
                  limit = 2, eval = T)
  
  
}
% Add one or more standard keywords, see file 'KEYWORDS' in the
% R documentation directory.
\keyword{ ~kwd1 }
\keyword{ ~kwd2 }% __ONLY ONE__ keyword per line

#+end_src

** sql_summarise
*** test-sql_summarise
#+name:sql_summarise
# tests/test-sql_summarise.r
#+begin_src R :session *R* :tangle no  :exports none :eval no
  ################################################################
  # name:sql_summarise
  
  require(swishdbtools)
  source("R/sql_summarise.r")
  require(plyr)
  summarise(baseball,
   duration = max(year) - min(year),
   nteams = length(unique(team)))
  head(baseball)
  head(
  plycount <- ddply(baseball, "id", summarise,
   duration = max(year) - min(year))
  #                  ,
  # nteams = length(unique(team)))
  #)
  ewedb <- connect2postgres2('ewedb')
  sql_subset(ewedb, 'baseball', limit = 10, eval = T)
  undebug(sql_summarise)
  sqlmax <- sql_summarise(
    conn = ewedb
    ,
    x = "baseball"
    ,
    .dimensions = "id"
    ,
    .variables = "year"
    ,
    .fun = "max"
    ,
    eval = T
    ,
    check = T
    )
  sqlmin <- sql_summarise(ewedb, 'baseball', 'id', 'year', c('min', 'max'), eval = F)
  cat(sqlmin)
  sqlcount <- dbGetQuery(ewedb, sqlmin)
  #  merge(sqlmax, sqlmin)
  sqlcount$duration <- sqlcount$year_max - sqlcount$year_min
  head(sqlcount)
  
  head(plycount)
  
#+end_src
*** R-sql_summarise
#+name:sql_summarise
#+begin_src R :session *R* :tangle R/sql_summarise.r :exports none :eval no
  ################################################################
  # name:sql_summarise
    sql_summarise <- function(conn, x, .dimensions, .variables, .fun, eval = FALSE, check = T)
    {
      # assume ch exists
      if(length(grep("\\.",x)) == 0)
        {
          schema <- "public"
          table <- x
        } else {
          schema <- strsplit(x, "\\.")[[1]][1]
          table <- strsplit(x, "\\.")[[1]][2]
        }
      if(check)
        {
        exists <- pgListTables(conn, schema, table)
        if(nrow(exists) == 0)
        {
          stop("Table doesn't exist.")
        }
  
        }
      dimensionsList <- paste(.dimensions, collapse = ", ", sep = "")
    if(.variables == "*")
      {
        variablesList <- names(
                         dbGetQuery(conn,
                          paste("select * from ",
                          schema, ".",
                          table, " limit 1",
                          sep = ""))
                         )
        variablesList <- variablesList[-which(variablesList == .dimensions)]
      } else {
        variablesList <- .variables
      }
      fun <- paste("), ",.fun, "(", sep = "")
      # TODO
      variablesList
      .fun
      variableslist <- paste(paste(.fun, "(", variablesList, ")", sep =
      ""),"as", paste(variablesList, "_", .fun, sep = ""), collapse =", ")
  
      #paste(paste(func, "(", vars, ")", sep = ""),"as", paste(vars, "_",
      #  func, sep = ""), collapse =", ")
      # variableslist <-  paste(.fun, "(",
      #                         paste(variablesList, collapse = fun, sep =
      #                    ""),
      #                         ")", sep ="")
  
  #variableslist
      sqlquery <- paste("select ", dimensionsList, ", ", variableslist, "\nfrom ", schema, ".",
                        table, "\ngroup by ",dimensionsList,"\norder by ",dimensionsList,
                        sep = "")
  # cat(sqlquery)
  
      if(eval)
        {
          dat <- dbGetQuery(conn,sqlquery)
          return(dat)
        } else {
          return(sqlquery)
        }
  
    }
  
#+end_src
*** man-sql_summarise
#+name:sql_summarise
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:sql_summarise

#+end_src

** sql_join
*** test-sql_join
#+name:sql_join
#+begin_src R :session *R:2* :tangle no :exports none :eval no
  ################################################################
  # name:sql_join
  require(swishdbtools)
  ewedb <- connect2postgres2("ewedb")
  
  source("R/sql_join.r")
  
  
  first <- ddply(baseball, "id", summarise, first = min(year))
  #     system.time(
         b2 <- merge(baseball, first, by = "id", all.x = TRUE)
  #       )
       system.time(b3 <- join(baseball, first, by = "id"))
  
  
  first2 <- sql_summarise(ewedb, "baseball", "id", "year", "min", eval =T)
  head(first); head(first2)
  dbWriteTable(ewedb, "baseball_first", first2, row.names = F)
  debug(sql_join)
  sql <- sql_join(
    conn = ewedb
    ,
    select.x = "*"
    ,
    select.y = "*"
    ,
    x = "baseball"
    ,
    y = "baseball_first"
    ,
    by = "id"
    ,
    by.x = by
    ,
    by.y = by
    ,
    type = "left"
    ,
    eval = FALSE
    ,
    check = T
    )
  cat(sql)
  dat <- dbGetQuery(ewedb, sql)
  dat <- arrange(dat, id, year)
  head(dat)
  b2 <- arrange(b2, id, year)
  head(b2)
  
#+end_src
*** R-sql_join
#+name:sql_join
#+begin_src R :session *R* :tangle R/sql_join.r :exports none :eval no
   ################################################################
   # name:sql_join
     sql_join <- function(conn, x, y, select.x = "*", select.y = "*", by, by.x = by, by.y = by,
                                 type = "left", eval = FALSE, check = T)
     {
       # assume ch exists
       if(length(grep("\\.",x)) == 0)
         {
           schema_x <- "public"
           table_x <- x
         } else {
           schema_x <- strsplit(x, "\\.")[[1]][1]
           table_x <- strsplit(x, "\\.")[[1]][2]
         }
       if(length(grep("\\.",y)) == 0)
         {
           schema_y <- "public"
           table_y <- y
         } else {
           schema_y <- strsplit(y, "\\.")[[1]][1]
           table_y <- strsplit(y, "\\.")[[1]][2]
         }
   
   
   
       if(check)
         {
         exists <- pgListTables(conn, schema_x, table_x)
         if(nrow(exists) == 0)
         {
           stop("Table x doesn't exist.")
         }
   
         }
   
   ## check cols exist in both and then paste together
       if(check & select.x=="*")
         {
           select_x <- names(
                          dbGetQuery(conn,
                           paste("select ", select.x, " from ",
                           schema_x, ".",
                           table_x, " limit 1",
                           sep = ""))
                          )
   
         } else { select_x <- select.x }
   #    select_x
       if(check & select.y=="*")
         {
           select_y <- names(
                          dbGetQuery(conn,
                           paste("select ", select.y, " from ",
                           schema_y, ".",
                           table_y, " limit 1",
                           sep = ""))
                          )
   
         } else { select_y <- select.y }
   #    select_y
   
       select.x <- paste("t1.", select_x,collapse = ", ", sep = "")
       for(.by in by)
         {
           recordIndex <- which(.by == select_y)
           select_y <- select_y[-recordIndex]
         }
       select.y <- paste("t2.",select_y, collapse = ", ", sep = "")
   
   #    select
       sqlquery <- paste("select ", select.x, ", ", select.y ,
                         "\nfrom ",
                         schema_x , ".",
                         table_x , " t1\n",
                         type, " join\n",
                         schema_y , ".",
                         table_y , " t2\n",
                         "on t1.", by.x, " = t2.", by.y,
                         sep = "")
  #  cat(sqlquery)
       ## if(!is.na(subset))
       ##   {
       ##     sqlquery <- paste(sqlquery, "where ", subset, "\n", sep = "")
       ##   }
   
       ## if(limit > 0)
       ##   {
       ##     sqlquery <- paste(sqlquery, "limit ", limit, "\n", sep = "")
       ##   }
   
       if(eval)
         {
           dat <- dbGetQuery(conn,sqlquery)
           return(dat)
         } else {
           return(sqlquery)
         }
   
   
     }
   
#+end_src
*** man-sql_join
#+name:sql_join
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:sql_join

#+end_src
** sql_transform
*** test-sql_transform
#+name:sql_transform
#+begin_src R :session *R* :tangle no :exports none :eval no
  ################################################################
  # name:sql_transform
  require(plyr)
  ## ?transform
  ## Arguments:
  
  ##    _data: The object to be transformed
  
  ##      ...: Further arguments of the form tag=value
  
       transform(airquality, Ozone = -Ozone)
       transform(airquality, new = -Ozone, Temp = (Temp-32)/1.8)
  
       attach(airquality)
       transform(Ozone, logOzone = log(Ozone)) # marginally interesting ...
       detach(airquality)
  
#+end_src
*** R-sql_transform
#+name:sql_transform
#+begin_src R :session *R* :tangle R/sql_transform.r :exports none :eval no
  ################################################################
  # name:sql_transform
     sql_transform <- function(conn, x,
                               eval = FALSE, check = T)
     {
       # assume ch exists
       if(length(grep("\\.",x)) == 0)
         {
           schema_x <- "public"
           table_x <- x
         } else {
           schema_x <- strsplit(x, "\\.")[[1]][1]
           table_x <- strsplit(x, "\\.")[[1]][2]
         }
       if(length(grep("\\.",y)) == 0)
         {
           schema_y <- "public"
           table_y <- y
         } else {
           schema_y <- strsplit(y, "\\.")[[1]][1]
           table_y <- strsplit(y, "\\.")[[1]][2]
         }
  
  
  
       if(check)
         {
         exists <- pgListTables(conn, schema_x, table_x)
         if(nrow(exists) == 0)
         {
           stop("Table x doesn't exist.")
         }
  
         }
  
   ## check cols exist in both and then paste together
       if(check & select.x=="*")
         {
           select_x <- names(
                          dbGetQuery(conn,
                           paste("select ", select.x, " from ",
                           schema_x, ".",
                           table_x, " limit 1",
                           sep = ""))
                          )
  
         }
   #    select_x
       if(check & select.y=="*")
         {
           select_y <- names(
                          dbGetQuery(conn,
                           paste("select ", select.y, " from ",
                           schema_y, ".",
                           table_y, " limit 1",
                           sep = ""))
                          )
  
         }
   #    select_y
  
       select.x <- paste("t1.", select_x,collapse = ", ", sep = "")
       for(.by in by)
         {
           recordIndex <- which(.by == select_y)
           select_y <- select_y[-recordIndex]
         }
       select.y <- paste("t2.",select_y, collapse = ", ", sep = "")
  
   #    select
       sqlquery <- paste("select ", select.x, ", ", select.y ,
                         "\nfrom ",
                         schema_x , ".",
                         table_x , " t1\n",
                         type, " join\n",
                         schema_y , ".",
                         table_y , " t2\n",
                         "on t1.", by.x, " = t2.", by.y,
                         sep = "")
  #  cat(sqlquery)
       ## if(!is.na(subset))
       ##   {
       ##     sqlquery <- paste(sqlquery, "where ", subset, "\n", sep = "")
       ##   }
  
       ## if(limit > 0)
       ##   {
       ##     sqlquery <- paste(sqlquery, "limit ", limit, "\n", sep = "")
       ##   }
  
       if(eval)
         {
           dat <- dbGetQuery(conn,sqlquery)
           return(dat)
         } else {
           return(sqlquery)
         }
  
  
     }
  
#+end_src
*** man-sql_transform
#+name:sql_transform
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:sql_transform

#+end_src
